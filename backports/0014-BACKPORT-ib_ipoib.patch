From: Alex Vesker <valex@mellanox.com>
Subject: [PATCH] BACKPORT: ib_ipoib

Add only ib_ipoib backports to this patch.
That is:
- drivers/infiniband/ulp/ipoib

Change-Id: Ib0af85dede52bc84ae441878e052a2a0867f4b07
Signed-off-by: Alex Vesker <valex@mellanox.com>
---
 drivers/infiniband/ulp/ipoib/ipoib.h               |  21 ++
 drivers/infiniband/ulp/ipoib/ipoib_cm.c            |   9 +-
 drivers/infiniband/ulp/ipoib/ipoib_ethtool.c       |  47 ++++
 drivers/infiniband/ulp/ipoib/ipoib_ib.c            |  16 +-
 drivers/infiniband/ulp/ipoib/ipoib_main.c          | 241 +++++++++++++++++++--
 drivers/infiniband/ulp/ipoib/ipoib_multicast.c     |  15 ++
 drivers/infiniband/ulp/ipoib/ipoib_netlink.c       |  20 +-
 drivers/infiniband/ulp/ipoib/ipoib_vlan.c          |   4 +-
 .../ulp/ipoib/rss_tss/ipoib_ethtool_rss.c          |  24 +-
 .../infiniband/ulp/ipoib/rss_tss/ipoib_ib_rss.c    |  18 +-
 .../infiniband/ulp/ipoib/rss_tss/ipoib_main_rss.c  |  67 +++++-
 drivers/infiniband/ulp/ipoib/rss_tss/ipoib_rss.h   |   3 +
 12 files changed, 458 insertions(+), 27 deletions(-)

--- a/drivers/infiniband/ulp/ipoib/ipoib.h
+++ b/drivers/infiniband/ulp/ipoib/ipoib.h
@@ -42,6 +42,7 @@
 #include <linux/kref.h>
 #include <linux/if_infiniband.h>
 #include <linux/mutex.h>
+#include <linux/ratelimit.h>
 
 #include <net/neighbour.h>
 #include <net/sch_generic.h>
@@ -53,6 +54,9 @@
 #include <rdma/ib_sa.h>
 #include <rdma/rn_ipoib.h>
 #include <linux/sched.h>
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+#include <linux/inet_lro.h>
+#endif
 /* constants */
 
 enum ipoib_flush_level {
@@ -120,8 +124,19 @@ enum {
 	IPOIB_NON_CHILD		  = 0,
 	IPOIB_LEGACY_CHILD	  = 1,
 	IPOIB_RTNL_CHILD	  = 2,
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	IPOIB_MAX_LRO_DESCRIPTORS = 8,
+	IPOIB_LRO_MAX_AGGR      = 64,
+#endif
 };
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+struct ipoib_lro {
+	struct net_lro_mgr lro_mgr;
+	struct net_lro_desc lro_desc[IPOIB_MAX_LRO_DESCRIPTORS];
+};
+#endif
+
 #define	IPOIB_OP_RECV   (1ul << 31)
 #ifdef CONFIG_INFINIBAND_IPOIB_CM
 #define	IPOIB_OP_CM     (1ul << 30)
@@ -448,6 +463,12 @@ struct ipoib_dev_priv {
 	bool sm_fullmember_sendonly_support;
 	const struct net_device_ops	*rn_ops;
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	struct ipoib_lro lro;
+#endif
+#if (!defined(HAVE_NDO_GET_STATS64) || !defined(HAVE_NETDEV_STATS_TO_STATS64))
+	struct net_device_stats ret_stats;
+#endif
 	/* Function pointers for RSS support */
 	struct ipoib_func_pointers fp;
 };
--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
@@ -1491,7 +1491,11 @@ static void ipoib_cm_skb_reap(struct wor
 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));
 #if IS_ENABLED(CONFIG_IPV6)
 		else if (skb->protocol == htons(ETH_P_IPV6))
+#ifdef HAVE_ICMPV6_SEND_4_PARAMS
 			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
+#else
+			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, priv->dev);
+#endif
 #endif
 		dev_kfree_skb_any(skb);
 
@@ -1510,8 +1514,11 @@ void ipoib_cm_skb_too_long(struct net_de
 	int e = skb_queue_empty(&priv->cm.skb_queue);
 
 	if (skb_dst(skb))
+#if defined HAVE_UPDATE_PMTU_4_PARAMS
 		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
-
+#else
+		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);
+#endif
 	skb_queue_tail(&priv->cm.skb_queue, skb);
 	if (e)
 		queue_work(priv->wq, &priv->cm.skb_task);
--- a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
@@ -282,6 +282,34 @@ static int ipoib_get_sset_count(struct n
 	return -EOPNOTSUPP;
 }
 
+#ifndef HAVE_NETDEV_HW_FEATURES
+#if defined(HAVE_GET_SET_FLAGS) && defined(CONFIG_COMPAT_LRO_ENABLED_IPOIB)
+int ipoib_set_flags(struct net_device *dev, u32 data)
+{
+	struct ipoib_dev_priv *priv = ipoib_priv(dev);
+	int hw_support_lro = 0;
+
+#ifdef HAVE_NETDEV_HW_FEATURES
+	hw_support_lro = priv->dev->hw_features & NETIF_F_RXCSUM;
+#else
+	hw_support_lro = priv->dev->features & NETIF_F_RXCSUM;
+#endif
+
+	if ((data & ETH_FLAG_LRO) && hw_support_lro)
+		dev->features |= NETIF_F_LRO;
+	else
+		dev->features &= ~NETIF_F_LRO;
+	return 0;
+}
+#endif
+#ifdef HAVE_GET_SET_RX_CSUM
+static u32 ipoib_get_rx_csum(struct net_device *dev)
+{
+	return dev->features & NETIF_F_RXCSUM;
+}
+#endif
+#endif
+
 static const struct ethtool_ops ipoib_ethtool_ops = {
 	.get_drvinfo		= ipoib_get_drvinfo,
 	.get_coalesce		= ipoib_get_coalesce,
@@ -293,6 +321,25 @@ static const struct ethtool_ops ipoib_et
 	.get_sset_count		= ipoib_get_sset_count,
 	.set_ringparam		= ipoib_set_ring_param,
 	.get_ringparam		= ipoib_get_ring_param,
+/* IPoIB current code supports HW_FEATURES and doesn't
+ * support EXTENDED_HW_FEATURES. If support for EXTENDED_HW_FEATURES
+ * is added then this code and the set function should be masked
+ *  with LEGACY_ETHTOOL_OPS.
+ */
+#ifndef HAVE_NETDEV_HW_FEATURES
+#ifdef HAVE_GET_SET_FLAGS
+#if defined (CONFIG_COMPAT_LRO_ENABLED_IPOIB)
+	.set_flags              = ipoib_set_flags,
+#endif
+	.get_flags              = ethtool_op_get_flags,
+#endif
+#ifdef HAVE_GET_SET_TSO
+	.set_tso                = ethtool_op_set_tso,
+#endif
+#ifdef HAVE_GET_SET_RX_CSUM
+	.get_rx_csum 		= ipoib_get_rx_csum,
+#endif
+#endif
 };
 
 void ipoib_set_ethtool_ops(struct net_device *dev)
--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
@@ -284,7 +284,10 @@ static void ipoib_ib_handle_rx_wc(struct
 	}
 
 	skb_pull(skb, IB_GRH_BYTES);
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)) && ! defined(HAVE_SK_BUFF_CSUM_LEVEL)
+	/* indicate size for reasmb, only for old kernels */
+	skb->truesize = SKB_TRUESIZE(skb->len);
+#endif
 	skb->protocol = ((struct ipoib_header *) skb->data)->proto;
 	skb_add_pseudo_hdr(skb);
 
@@ -299,7 +302,14 @@ static void ipoib_ib_handle_rx_wc(struct
 			likely(wc->wc_flags & IB_WC_IP_CSUM_OK))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	if (dev->features & NETIF_F_LRO)
+		lro_receive_skb(&priv->lro.lro_mgr, skb, NULL);
+	else
+		netif_receive_skb(skb);
+#else
 	napi_gro_receive(&priv->recv_napi, skb);
+#endif
 
 repost:
 	if (unlikely(ipoib_ib_post_receive(dev, wr_id)))
@@ -517,6 +527,10 @@ poll_more:
 	}
 
 	if (done < budget) {
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+		if (dev->features & NETIF_F_LRO)
+			lro_flush_all(&priv->lro.lro_mgr);
+#endif
 		napi_complete(napi);
 		if (unlikely(ib_req_notify_cq(priv->recv_cq,
 					      IB_CQ_NEXT_COMP |
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -108,7 +108,9 @@ static struct net_device *ipoib_get_net_
 		struct ib_device *dev, u8 port, u16 pkey,
 		const union ib_gid *gid, const struct sockaddr *addr,
 		void *client_data);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 static int ipoib_set_mac(struct net_device *dev, void *addr);
+#endif
 static int ipoib_get_hca_features(struct ipoib_dev_priv *priv,
 				  struct ib_device *hca);
 static int ipoib_ioctl(struct net_device *dev, struct ifreq *ifr,
@@ -207,6 +209,7 @@ static void ipoib_uninit(struct net_devi
 	priv->fp.ipoib_dev_cleanup(dev);
 }
 
+#ifdef HAVE_NDO_FIX_FEATURES
 static netdev_features_t ipoib_fix_features(struct net_device *dev, netdev_features_t features)
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
@@ -220,6 +223,7 @@ static netdev_features_t ipoib_fix_featu
 
 	return features;
 }
+#endif
 
 static int ipoib_change_mtu(struct net_device *dev, int new_mtu)
 {
@@ -266,16 +270,41 @@ static int ipoib_change_mtu(struct net_d
 
 	return ret;
 }
-
+#ifdef HAVE_NDO_GET_STATS64_RET_VOID
 static void ipoib_get_stats(struct net_device *dev,
 			    struct rtnl_link_stats64 *stats)
+#elif defined(HAVE_NDO_GET_STATS64)
+static struct rtnl_link_stats64 * ipoib_get_stats(struct net_device *dev,
+						  struct rtnl_link_stats64 *stats)
+#else
+static struct net_device_stats *  ipoib_get_stats(struct net_device *dev)
+#endif
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
-
+#if !defined(HAVE_NDO_GET_STATS64) && !defined(HAVE_NDO_GET_STATS64_RET_VOID)
+	struct net_device_stats *stats = &priv->ret_stats;
+#endif
+#ifdef HAVE_NDO_GET_STATS64_RET_VOID
 	if (priv->rn_ops->ndo_get_stats64)
 		priv->rn_ops->ndo_get_stats64(dev, stats);
 	else
 		netdev_stats_to_stats64(stats, &dev->stats);
+#elif defined(HAVE_NDO_GET_STATS64)
+	if (priv->rn_ops->ndo_get_stats64) {
+  		return priv->rn_ops->ndo_get_stats64(dev, stats);
+	} else {
+		netdev_stats_to_stats64(stats,
+					&dev->stats);
+	return stats;
+	}
+#else
+	if (priv->rn_ops->ndo_get_stats) {
+		return priv->rn_ops->ndo_get_stats(dev);
+		} else {
+			memcpy(stats, &dev->stats, sizeof(priv->ret_stats));
+			return stats;
+		}
+#endif
 }
 
 
@@ -295,10 +324,21 @@ static bool ipoib_is_dev_match_addr_rcu(
 		in_dev = in_dev_get(dev);
 		if (!in_dev)
 			return false;
-
+#ifdef HAVE_INET_CONFIRM_ADDR_EXPORTED
+#ifdef HAVE_INET_CONFIRM_ADDR_5_PARAMS
 		ret_addr = inet_confirm_addr(net, in_dev, 0,
 					     addr_in->sin_addr.s_addr,
 					     RT_SCOPE_HOST);
+#else
+		ret_addr = inet_confirm_addr(in_dev, 0,
+					     addr_in->sin_addr.s_addr,
+					     RT_SCOPE_HOST);
+#endif
+#else
+		ret_addr = confirm_addr_indev(in_dev, 0,
+					      addr_in->sin_addr.s_addr,
+					      RT_SCOPE_HOST);
+#endif
 		in_dev_put(in_dev);
 		if (ret_addr)
 			return true;
@@ -343,6 +383,7 @@ struct ipoib_walk_data {
 	struct net_device *result;
 };
 
+#ifdef HAVE_NETDEV_WALK_ALL_UPPER_DEV_RCU
 static int ipoib_upper_walk(struct net_device *upper, void *_data)
 {
 	struct ipoib_walk_data *data = _data;
@@ -356,6 +397,7 @@ static int ipoib_upper_walk(struct net_d
 
 	return ret;
 }
+#endif
 
 /**
  * Find a net_device matching the given address, which is an upper device of
@@ -369,9 +411,12 @@ static int ipoib_upper_walk(struct net_d
 static struct net_device *ipoib_get_net_dev_match_addr(
 		const struct sockaddr *addr, struct net_device *dev)
 {
-	struct ipoib_walk_data data = {
-		.addr = addr,
-	};
+        struct ipoib_walk_data data = {
+                .addr = addr,
+        };
+#ifndef HAVE_NETDEV_WALK_ALL_UPPER_DEV_RCU
+	struct net_device *upper;
+#endif
 
 	rcu_read_lock();
 	if (ipoib_is_dev_match_addr_rcu(addr, dev)) {
@@ -379,8 +424,18 @@ static struct net_device *ipoib_get_net_
 		data.result = dev;
 		goto out;
 	}
-
+#ifdef HAVE_NETDEV_WALK_ALL_UPPER_DEV_RCU
 	netdev_walk_all_upper_dev_rcu(dev, ipoib_upper_walk, &data);
+#else
+	for_each_netdev(&init_net, upper) {
+                if (ipoib_is_dev_match_addr_rcu(addr, upper)) {
+                        dev_hold(upper);
+                        data.result = upper;
+                        break;
+                }
+        }
+#endif
+
 out:
 	rcu_read_unlock();
 	return data.result;
@@ -529,7 +584,11 @@ int ipoib_set_mode(struct net_device *de
 			set_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
 			ipoib_warn(priv, "enabling connected mode "
 				   "will cause multicast packet drops\n");
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)
 			netdev_update_features(dev);
+#else
+			dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO);
+#endif
 			dev_set_mtu(dev, ipoib_cm_max_mtu(dev));
 			rtnl_unlock();
 			priv->tx_wr.wr.send_flags &= ~IB_SEND_IP_CSUM;
@@ -545,7 +604,19 @@ int ipoib_set_mode(struct net_device *de
 
 	if (!strcmp(buf, "datagram\n")) {
 		clear_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)
 		netdev_update_features(dev);
+#else
+		if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM)
+			dev->features |= NETIF_F_IP_CSUM;
+
+		if (priv->max_send_sge > 1)
+			dev->features |= NETIF_F_SG;
+
+		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+			if (dev->features & (NETIF_F_IP_CSUM | NETIF_F_SG))
+				dev->features |= NETIF_F_TSO;
+#endif
 		dev_set_mtu(dev, min(priv->mcast_mtu, dev->mtu));
 		rtnl_unlock();
 		ipoib_flush_paths(dev);
@@ -1342,6 +1413,7 @@ static void ipoib_set_mcast_list(struct
 	queue_work(priv->wq, &priv->restart_task);
 }
 
+#ifdef HAVE_NDO_GET_IFLINK
 static int ipoib_get_iflink(const struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
@@ -1353,6 +1425,76 @@ static int ipoib_get_iflink(const struct
 	/* child/vlan interface */
 	return priv->parent->ifindex;
 }
+#endif
+
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+static int get_skb_hdr(struct sk_buff *skb, void **iphdr,
+		       void **tcph, u64 *hdr_flags, void *priv)
+{
+	unsigned int ip_len;
+	struct iphdr *iph;
+
+	if (unlikely(skb->protocol != htons(ETH_P_IP)))
+		return -1;
+
+	/*
+	* In the future we may add an else clause that verifies the
+	* checksum and allows devices which do not calculate checksum
+	* to use LRO.
+	*/
+	if (unlikely(skb->ip_summed != CHECKSUM_UNNECESSARY))
+		return -1;
+
+	/* Check for non-TCP packet */
+	skb_reset_network_header(skb);
+	iph = ip_hdr(skb);
+	if (iph->protocol != IPPROTO_TCP)
+		return -1;
+
+	ip_len = ip_hdrlen(skb);
+	skb_set_transport_header(skb, ip_len);
+	*tcph = tcp_hdr(skb);
+
+	/* check if IP header and TCP header are complete */
+	if (ntohs(iph->tot_len) < ip_len + tcp_hdrlen(skb))
+		return -1;
+
+	*hdr_flags = LRO_IPV4 | LRO_TCP;
+	*iphdr = iph;
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+static void ipoib_lro_setup(struct ipoib_dev_priv *priv)
+{
+	priv->lro.lro_mgr.max_aggr		= IPOIB_LRO_MAX_AGGR;
+	priv->lro.lro_mgr.max_desc		= IPOIB_MAX_LRO_DESCRIPTORS;
+	priv->lro.lro_mgr.lro_arr		= priv->lro.lro_desc;
+	priv->lro.lro_mgr.get_skb_header	= get_skb_hdr;
+	priv->lro.lro_mgr.features		= LRO_F_NAPI;
+	priv->lro.lro_mgr.dev			= priv->dev;
+	priv->lro.lro_mgr.ip_summed_aggr	= CHECKSUM_UNNECESSARY;
+}
+#endif
+
+void set_lro_features_bit(struct ipoib_dev_priv *priv)
+{
+	u64 hw_support_lro = 0;
+#ifdef HAVE_NETDEV_HW_FEATURES
+	hw_support_lro = priv->dev->hw_features & NETIF_F_RXCSUM;
+#else
+	hw_support_lro = (priv->dev->features & NETIF_F_RXCSUM);
+#endif
+	if (hw_support_lro) {
+		priv->dev->features |= NETIF_F_LRO;
+#ifdef HAVE_NETDEV_HW_FEATURES
+		priv->dev->hw_features |= NETIF_F_LRO;
+		priv->dev->wanted_features |= NETIF_F_LRO;
+#endif
+	}
+}
+#endif
 
 static u32 ipoib_addr_hash(struct ipoib_neigh_hash *htbl, u8 *daddr)
 {
@@ -1813,6 +1955,9 @@ static int ipoib_dev_init_default(struct
 	if (!priv->rx_ring)
 		goto out_napi_cleanup;
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	ipoib_lro_setup(priv);
+#endif
 	atomic_set(&priv->tx_outstanding, 0);
 
 	priv->tx_ring = vzalloc(priv->sendq_size * sizeof(*priv->tx_ring));
@@ -1938,15 +2083,27 @@ void ipoib_dev_cleanup(struct net_device
 		/* Stop GC on child */
 		set_bit(IPOIB_STOP_NEIGH_GC, &cpriv->flags);
 		cancel_delayed_work(&cpriv->neigh_reap_task);
-		unregister_netdevice_queue(cpriv->dev, &head);
 
 		/* Let the unregister function take care of device freeing */
+#ifdef HAVE_NET_DEVICE_NEEDS_FREE_NETDEV
 		cpriv->dev->needs_free_netdev = true;
 		if (cpriv->ca->free_rdma_netdev && ipoib_enhanced_enabled)
 			cpriv->dev->priv_destructor = cpriv->ca->free_rdma_netdev;
+#else
+		if (cpriv->ca->free_rdma_netdev && ipoib_enhanced_enabled)
+			cpriv->dev->destructor = cpriv->ca->free_rdma_netdev;
+		else
+			cpriv->dev->destructor = free_netdev;
+#endif
+#ifdef HAVE_UNREGISTER_NETDEVICE_QUEUE
+		unregister_netdevice_queue(cpriv->dev, &head);
 	}
 	unregister_netdevice_many(&head);
-
+#else
+	}
+	list_for_each_entry_safe(cpriv, tcpriv, &priv->child_intfs, list)
+		unregister_netdevice(cpriv->dev);
+#endif
 	ipoib_neigh_hash_uninit(dev);
 
 	ipoib_ib_dev_cleanup(dev);
@@ -1959,12 +2116,14 @@ void ipoib_dev_cleanup(struct net_device
 	}
 }
 
+#ifdef HAVE_NETDEV_OPS_NDO_SET_VF_LINK_STATE
 static int ipoib_set_vf_link_state(struct net_device *dev, int vf, int link_state)
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
 
 	return ib_set_vf_link_state(priv->ca, vf, priv->port, link_state);
 }
+#endif
 
 static int ipoib_get_vf_config(struct net_device *dev, int vf,
 			       struct ifla_vf_info *ivf)
@@ -1981,6 +2140,7 @@ static int ipoib_get_vf_config(struct ne
 	return 0;
 }
 
+#ifdef HAVE_NDO_SET_VF_GUID
 static int ipoib_set_vf_guid(struct net_device *dev, int vf, u64 guid, int type)
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
@@ -1990,7 +2150,9 @@ static int ipoib_set_vf_guid(struct net_
 
 	return ib_set_vf_guid(priv->ca, vf, priv->port, guid, type);
 }
+#endif
 
+#ifdef HAVE_NDO_GET_VF_STATS
 static int ipoib_get_vf_stats(struct net_device *dev, int vf,
 			      struct ifla_vf_stats *vf_stats)
 {
@@ -1998,6 +2160,7 @@ static int ipoib_get_vf_stats(struct net
 
 	return ib_get_vf_stats(priv->ca, vf, priv->port, vf_stats);
 }
+#endif
 
 static const struct header_ops ipoib_header_ops = {
 	.create	= ipoib_hard_header,
@@ -2008,17 +2171,33 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit		 = ipoib_start_xmit,
 	.ndo_tx_timeout		 = ipoib_timeout,
+#if defined(HAVE_NDO_GET_STATS64) || defined(HAVE_NDO_GET_STATS64_RET_VOID)
 	.ndo_get_stats64	 = ipoib_get_stats,
+#else
+	.ndo_get_stats           = ipoib_get_stats,
+#endif
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
+#ifdef HAVE_NETDEV_OPS_NDO_SET_VF_LINK_STATE
 	.ndo_set_vf_link_state	 = ipoib_set_vf_link_state,
+#endif
 	.ndo_get_vf_config	 = ipoib_get_vf_config,
+#ifdef HAVE_NDO_GET_VF_STATS
 	.ndo_get_vf_stats	 = ipoib_get_vf_stats,
+#endif
+#ifdef HAVE_NDO_SET_VF_GUID
 	.ndo_set_vf_guid	 = ipoib_set_vf_guid,
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 	.ndo_set_mac_address	 = ipoib_set_mac,
+#endif
 	.ndo_do_ioctl		 = ipoib_ioctl,
 };
 
@@ -2027,12 +2206,16 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit	 	 = ipoib_start_xmit,
 	.ndo_tx_timeout		 = ipoib_timeout,
 	.ndo_get_stats		 = NULL, /* TODO */
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
 	.ndo_do_ioctl		 = ipoib_ioctl,
 };
 
@@ -2052,7 +2235,12 @@ void ipoib_setup_common(struct net_devic
 	dev->tx_queue_len	 = ipoib_sendq_size * 2;
 	dev->features		 = (NETIF_F_VLAN_CHALLENGED	|
 				    NETIF_F_HIGHDMA);
+
+#ifdef HAVE_NETIF_KEEP_DST
 	netif_keep_dst(dev);
+#else
+	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
+#endif
 
 	memcpy(dev->broadcast, ipv4_bcast_addr, INFINIBAND_ALEN);
 }
@@ -2096,9 +2284,10 @@ static struct net_device *ipoib_create_n
 	struct net_device *dev;
 	struct rdma_netdev *rn;
 
-	dev = alloc_netdev((int)sizeof(struct ipoib_rdma_netdev),
-			   name,
-			   NET_NAME_UNKNOWN, setup);
+        dev = alloc_netdev_mqs((int)sizeof(struct ipoib_rdma_netdev),
+                               name,
+                               NET_NAME_UNKNOWN, setup, 1, 1);
+
 	if (!dev)
 		return NULL;
 
@@ -2248,6 +2437,7 @@ static void set_base_guid(struct ipoib_d
 	}
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 static int ipoib_check_lladdr(struct net_device *dev,
 			      struct sockaddr_storage *ss)
 {
@@ -2273,9 +2463,13 @@ static int ipoib_set_mac(struct net_devi
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
 	struct sockaddr_storage *ss = addr;
-	int ret;
+	int ret = 0;
 
+#if defined HAVE_NETDEV_IFF_LIVE_ADDR_CHANGE
 	if (!(dev->priv_flags & IFF_LIVE_ADDR_CHANGE) && netif_running(dev))
+#else
+	if (!netif_running(dev))
+#endif
 		return -EBUSY;
 
 	ret = ipoib_check_lladdr(dev, ss);
@@ -2288,6 +2482,7 @@ static int ipoib_set_mac(struct net_devi
 
 	return 0;
 }
+#endif
 
 static ssize_t ipoib_set_mac_using_sysfs(struct device *dev,
 					 struct device_attribute *attr,
@@ -2361,12 +2556,19 @@ void ipoib_set_dev_features(struct ipoib
 	ipoib_get_hca_features(priv, hca);
 
 	if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM) {
+#ifdef HAVE_NETDEV_HW_FEATURES
 		priv->dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
 
 		if (priv->hca_caps & IB_DEVICE_UD_TSO)
 			priv->dev->hw_features |= NETIF_F_TSO;
 
 		priv->dev->features |= priv->dev->hw_features;
+#else
+		priv->dev->features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
+
+		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+			priv->dev->features |= NETIF_F_TSO;
+#endif
 	}
 }
 
@@ -2400,10 +2602,12 @@ static struct net_device *ipoib_add_port
 	/* MTU will be reset when mcast join happens */
 	priv->dev->mtu  = IPOIB_UD_MTU(priv->max_ib_mtu);
 	priv->mcast_mtu  = priv->admin_mtu = priv->dev->mtu;
+#ifdef HAVE_NET_DEVICE_MIN_MAX_MTU
 	priv->dev->max_mtu = IPOIB_CM_MTU;
-
+#endif
+#if defined HAVE_NET_DEVICE_NEIGH_PRIV_LEN
 	priv->dev->neigh_priv_len = sizeof(struct ipoib_neigh);
-
+#endif
 	result = ib_query_pkey(hca, port, 0, &priv->pkey);
 	if (result) {
 		printk(KERN_WARNING "%s: ib_query_pkey port %d failed (ret = %d)\n",
@@ -2455,6 +2659,13 @@ static struct net_device *ipoib_add_port
 		goto register_failed;
 	}
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	/* force lro on the dev->features, because the function
+	 * register_netdev disable it according to our private lro
+	 */
+	set_lro_features_bit(priv);
+#endif
+
 	ipoib_create_debug_files(priv->dev);
 
 	if (ipoib_cm_add_mode_attr(priv->dev))
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@ -897,7 +897,11 @@ void ipoib_mcast_restart_task(struct wor
 	struct ipoib_dev_priv *priv =
 		container_of(work, struct ipoib_dev_priv, restart_task);
 	struct net_device *dev = priv->dev;
+#ifdef HAVE_NETDEV_FOR_EACH_MC_ADDR
 	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *mclist;
+#endif
 	struct ipoib_mcast *mcast, *tmcast;
 	LIST_HEAD(remove_list);
 	unsigned long flags;
@@ -927,14 +931,25 @@ void ipoib_mcast_restart_task(struct wor
 		clear_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);
 
 	/* Mark all of the entries that are found or don't exist */
+#ifdef HAVE_NETDEV_FOR_EACH_MC_ADDR
 	netdev_for_each_mc_addr(ha, dev) {
+#else
+		for (mclist = dev->mc_list; mclist; mclist = mclist->next) {
+#endif
+
 		union ib_gid mgid;
 
+#ifdef HAVE_NETDEV_FOR_EACH_MC_ADDR
 		if (!ipoib_mcast_addr_is_valid(ha->addr, dev->broadcast))
 			continue;
 
 		memcpy(mgid.raw, ha->addr + 4, sizeof mgid);
+#else
+		if (!ipoib_mcast_addr_is_valid(mclist->dmi_addr, dev->broadcast))
+			continue;
 
+		memcpy(mgid.raw, mclist->dmi_addr + 4, sizeof mgid);
+#endif
 		mcast = __ipoib_mcast_find(dev, &mgid);
 		if (!mcast || test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {
 			struct ipoib_mcast *nmcast;
--- a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_netlink.c
@@ -93,8 +93,12 @@ out_err:
 	return ret;
 }
 
+#ifdef HAVE_RTNL_LINK_OPS_NEWLINK_4_PARAMS
 static int ipoib_new_child_link(struct net *src_net, struct net_device *dev,
-			       struct nlattr *tb[], struct nlattr *data[])
+#else
+static int ipoib_new_child_link(struct net_device *dev,
+#endif
+				struct nlattr *tb[], struct nlattr *data[])
 {
 	struct net_device *pdev;
 	struct ipoib_dev_priv *ppriv;
@@ -106,8 +110,12 @@ static int ipoib_new_child_link(struct n
 
 	if (!tb[IFLA_LINK])
 		return -EINVAL;
-
+#ifdef HAVE_RTNL_LINK_OPS_NEWLINK_4_PARAMS
 	pdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));
+#else
+	pdev = __dev_get_by_index(dev_net(dev), nla_get_u32(tb[IFLA_LINK]));
+#endif
+
 	if (!pdev || pdev->type != ARPHRD_INFINIBAND)
 		return -ENODEV;
 
@@ -140,7 +148,11 @@ static int ipoib_new_child_link(struct n
 	return err;
 }
 
+#ifdef HAVE_RTNL_LINK_OPS_DELLINK_2_PARAMS
 static void ipoib_unregister_child_dev(struct net_device *dev, struct list_head *head)
+#else
+static void ipoib_unregister_child_dev(struct net_device *dev)
+#endif
 {
 	struct ipoib_dev_priv *priv, *ppriv;
 
@@ -148,7 +160,11 @@ static void ipoib_unregister_child_dev(s
 	ppriv = ipoib_priv(priv->parent);
 
 	down_write(&ppriv->vlan_rwsem);
+#ifdef HAVE_RTNL_LINK_OPS_DELLINK_2_PARAMS
 	unregister_netdevice_queue(dev, head);
+#else
+	unregister_netdevice(dev);
+#endif
 	list_del(&priv->list);
 	up_write(&ppriv->vlan_rwsem);
 }
--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c
@@ -75,7 +75,9 @@ int __ipoib_vlan_add(struct ipoib_dev_pr
 	set_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags);
 	priv->dev->broadcast[8] = pkey >> 8;
 	priv->dev->broadcast[9] = pkey & 0xff;
-
+#ifndef HAVE_NDO_GET_IFLINK
+	priv->dev->iflink = ppriv->dev->ifindex;
+#endif
 	result = ipoib_dev_init(priv->dev, ppriv->ca, ppriv->port);
 	if (result < 0) {
 		ipoib_warn(ppriv, "failed to initialize subinterface: "
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ethtool_rss.c
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ethtool_rss.c
@@ -143,7 +143,7 @@ static int ipoib_get_sset_count_rss(stru
 	}
 	return -EOPNOTSUPP;
 }
-
+#ifdef HAVE_GET_SET_CHANNELS
 static void ipoib_get_channels(struct net_device *dev,
 			       struct ethtool_channels *channel)
 {
@@ -202,6 +202,7 @@ static int ipoib_set_channels(struct net
 
 	return ipoib_reinit_rss(dev, channel->rx_count, channel->tx_count);
 }
+#endif
 
 static const struct ethtool_ops ipoib_ethtool_ops_rss = {
 	.get_drvinfo		= ipoib_get_drvinfo,
@@ -212,10 +213,31 @@ static const struct ethtool_ops ipoib_et
 	.get_strings		= ipoib_get_strings_rss,
 	.get_ethtool_stats	= ipoib_get_ethtool_stats_rss,
 	.get_sset_count		= ipoib_get_sset_count_rss,
+#ifdef HAVE_GET_SET_CHANNELS
 	.get_channels		= ipoib_get_channels,
 	.set_channels		= ipoib_set_channels,
+#endif
 	.set_ringparam		= ipoib_set_ring_param,
 	.get_ringparam		= ipoib_get_ring_param,
+/* IPoIB current code supports HW_FEATURES and doesn't
+ * support EXTENDED_HW_FEATURES. If support for EXTENDED_HW_FEATURES
+ * is added then this code and the set function should be masked
+ * with LEGACY_ETHTOOL_OPS.
+ */
+#ifndef HAVE_NETDEV_HW_FEATURES
+#ifdef HAVE_GET_SET_FLAGS
+#if defined (CONFIG_COMPAT_LRO_ENABLED_IPOIB)
+	.set_flags              = ipoib_set_flags,
+#endif
+	.get_flags              = ethtool_op_get_flags,
+#endif
+#ifdef HAVE_GET_SET_TSO
+	.set_tso                = ethtool_op_set_tso,
+#endif
+#ifdef HAVE_GET_SET_RX_CSUM
+	.get_rx_csum		= ipoib_get_rx_csum,
+#endif
+#endif
 };
 
 static const struct ethtool_ops *ipoib_ethtool_ops_select;
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ib_rss.c
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ib_rss.c
@@ -216,7 +216,10 @@ static void ipoib_ib_handle_rx_wc_rss(st
 	}
 
 	skb_pull(skb, IB_GRH_BYTES);
-
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)) && ! defined(HAVE_SK_BUFF_CSUM_LEVEL)
+	/* indicate size for reasmb, only for old kernels */
+	skb->truesize = SKB_TRUESIZE(skb->len);
+#endif
 	skb->protocol = ((struct ipoib_header *) skb->data)->proto;
 	skb_add_pseudo_hdr(skb);
 
@@ -230,9 +233,14 @@ static void ipoib_ib_handle_rx_wc_rss(st
 	if ((dev->features & NETIF_F_RXCSUM) &&
 			likely(wc->wc_flags & IB_WC_IP_CSUM_OK))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
-
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	if (dev->features & NETIF_F_LRO)
+		lro_receive_skb(&recv_ring->lro.lro_mgr, skb, NULL);
+	else
+		netif_receive_skb(skb);
+#else
 	napi_gro_receive(&recv_ring->napi, skb);
-
+#endif
 repost:
 	if (unlikely(ipoib_ib_post_receive_rss(dev, recv_ring, wr_id)))
 		ipoib_warn(priv, "ipoib_ib_post_receive_rss failed "
@@ -328,6 +336,10 @@ poll_more:
 	}
 
 	if (done < budget) {
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+		if (dev->features & NETIF_F_LRO)
+			lro_flush_all(&rx_ring->lro.lro_mgr);
+#endif
 		napi_complete(napi);
 		if (unlikely(ib_req_notify_cq(rx_ring->recv_cq,
 					      IB_CQ_NEXT_COMP |
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_main_rss.c
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_main_rss.c
@@ -51,7 +51,11 @@ int ipoib_set_mode_rss(struct net_device
 		set_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
 		ipoib_warn(priv, "enabling connected mode "
 			   "will cause multicast packet drops\n");
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)  
 		netdev_update_features(dev);
+#else
+		dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO);
+#endif
 		dev_set_mtu(dev, ipoib_cm_max_mtu(dev));
 		rtnl_unlock();
 
@@ -69,7 +73,19 @@ int ipoib_set_mode_rss(struct net_device
 
 	if (!strcmp(buf, "datagram\n")) {
 		clear_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)
 		netdev_update_features(dev);
+#else
+		if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM)
+			dev->features |= NETIF_F_IP_CSUM;
+
+		if (priv->max_send_sge > 1)
+			dev->features |= NETIF_F_SG;
+
+		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+			if (dev->features & (NETIF_F_IP_CSUM | NETIF_F_SG))
+				dev->features |= NETIF_F_TSO;
+#endif
 		dev_set_mtu(dev, min(priv->mcast_mtu, dev->mtu));
 		rtnl_unlock();
 		ipoib_flush_paths(dev);
@@ -81,9 +97,16 @@ int ipoib_set_mode_rss(struct net_device
 	return -EINVAL;
 }
 
+#if defined(NDO_SELECT_QUEUE_HAS_ACCEL_PRIV) || defined(HAVE_SELECT_QUEUE_FALLBACK_T)
 static u16 ipoib_select_queue_sw_rss(struct net_device *dev, struct sk_buff *skb,
-				     void *accel_priv,
-				     select_queue_fallback_t fallback)
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
+				     void *accel_priv, select_queue_fallback_t fallback)
+#else
+				     void *accel_priv)
+#endif
+#else /* NDO_SELECT_QUEUE_HAS_ACCEL_PRIV || HAVE_SELECT_QUEUE_FALLBACK_T */
+static u16 ipoib_select_queue_sw_rss(struct net_device *dev, struct sk_buff *skb)
+#endif
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
 	struct ipoib_pseudo_header *phdr;
@@ -223,6 +246,20 @@ static struct ipoib_neigh *ipoib_neigh_c
 	return neigh;
 }
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+static void ipoib_lro_setup_rss(struct ipoib_recv_ring *recv_ring,
+				struct ipoib_dev_priv *priv)
+{
+	recv_ring->lro.lro_mgr.max_aggr  = IPOIB_LRO_MAX_AGGR;
+	recv_ring->lro.lro_mgr.max_desc  = IPOIB_MAX_LRO_DESCRIPTORS;
+	recv_ring->lro.lro_mgr.lro_arr   = recv_ring->lro.lro_desc;
+	recv_ring->lro.lro_mgr.get_skb_header = get_skb_hdr;
+	recv_ring->lro.lro_mgr.features  = LRO_F_NAPI;
+	recv_ring->lro.lro_mgr.dev               = priv->dev;
+	recv_ring->lro.lro_mgr.ip_summed_aggr = CHECKSUM_UNNECESSARY;
+}
+#endif
+
 int ipoib_dev_init_default_rss(struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
@@ -256,6 +293,9 @@ int ipoib_dev_init_default_rss(struct ne
 		}
 		recv_ring->dev = dev;
 		recv_ring->index = i;
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+		ipoib_lro_setup_rss(recv_ring, priv);
+#endif
 		recv_ring++;
 		rx_allocated++;
 	}
@@ -358,10 +398,15 @@ void ipoib_dev_cleanup_rss(struct net_de
 		/* Stop GC on child */
 		set_bit(IPOIB_STOP_NEIGH_GC, &cpriv->flags);
 		cancel_delayed_work(&cpriv->neigh_reap_task);
+#ifdef HAVE_UNREGISTER_NETDEVICE_QUEUE
 		unregister_netdevice_queue(cpriv->dev, &head);
 	}
 	unregister_netdevice_many(&head);
-
+#else
+	}
+	list_for_each_entry_safe(cpriv, tcpriv, &priv->child_intfs, list)
+		unregister_netdevice(cpriv->dev);
+#endif
 	ipoib_dev_uninit_rss(dev);
 }
 
@@ -675,18 +720,30 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit		 = ipoib_start_xmit,
 	.ndo_select_queue	 = ipoib_select_queue_sw_rss,
 	.ndo_tx_timeout		 = ipoib_timeout_rss,
 	.ndo_get_stats		 = ipoib_get_stats_rss,
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
+#ifdef HAVE_NETDEV_OPS_NDO_SET_VF_LINK_STATE
 	.ndo_set_vf_link_state	 = ipoib_set_vf_link_state,
+#endif
 	.ndo_get_vf_config	 = ipoib_get_vf_config,
+#ifdef HAVE_NDO_GET_VF_STATS
 	.ndo_get_vf_stats	 = ipoib_get_vf_stats,
+#endif
+#ifdef HAVE_NDO_SET_VF_GUID
 	.ndo_set_vf_guid	 = ipoib_set_vf_guid,
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 	.ndo_set_mac_address	 = ipoib_set_mac,
+#endif
 };
 
 static const struct net_device_ops ipoib_netdev_ops_vf_sw_tss = {
@@ -694,13 +751,17 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit	 	 = ipoib_start_xmit,
 	.ndo_select_queue 	 = ipoib_select_queue_sw_rss,
 	.ndo_tx_timeout		 = ipoib_timeout_rss,
 	.ndo_get_stats		 = ipoib_get_stats_rss,
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
 };
 
 struct net_device *ipoib_create_netdev_default_rss(struct ib_device *hca,
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_rss.h
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_rss.h
@@ -99,6 +99,9 @@ struct ipoib_recv_ring {
 	struct ipoib_rx_cm_info	cm;
 	struct ipoib_rx_ring_stats stats;
 	unsigned		index;
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	struct ipoib_lro lro;
+#endif
 };
 
 static inline void ipoib_build_sge_rss(struct ipoib_send_ring *send_ring,
