From: Eugenia Emantayev <eugenia@mellanox.com>
Subject: [PATCH] BACKPORT: mlx4_core

Add only mlx4_core backports to this patch.
That is:
    - drivers/net/ethernet/mellanox/mlx4/
    - include/linux/mlx4/

Change-Id: I027859ac91193cbeaabe3678ddae0c2a4724a868
Signed-off-by: Eugenia Emantayev <eugenia@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx4/cmd.c           | 67 +++++++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/eq.c            |  9 +++
 drivers/net/ethernet/mellanox/mlx4/fw.c            | 13 +++-
 drivers/net/ethernet/mellanox/mlx4/intf.c          |  4 ++
 drivers/net/ethernet/mellanox/mlx4/main.c          | 72 +++++++++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/mlx4.h          |  4 ++
 drivers/net/ethernet/mellanox/mlx4/pd.c            |  6 ++
 .../net/ethernet/mellanox/mlx4/resource_tracker.c  | 10 +++
 include/linux/mlx4/cmd.h                           |  3 +
 include/linux/mlx4/cq.h                            |  4 ++
 include/linux/mlx4/cq_exp.h                        |  2 +
 include/linux/mlx4/device.h                        |  9 ++-
 include/linux/mlx4/driver.h                        |  4 ++
 13 files changed, 203 insertions(+), 4 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -2116,8 +2116,10 @@ static int mlx4_master_activate_admin_st
 	int port, err;
 	struct mlx4_vport_state *vp_admin;
 	struct mlx4_vport_oper_state *vp_oper;
+#ifdef HAVE_ETH_P_8021AD
 	struct mlx4_slave_state *slave_state =
 		&priv->mfunc.master.slave_state[slave];
+#endif
 	struct mlx4_active_ports actv_ports = mlx4_get_active_ports(
 			&priv->dev, slave);
 	int min_port = find_first_bit(actv_ports.ports,
@@ -2159,13 +2161,16 @@ static int mlx4_master_activate_admin_st
 					return err;
 				}
 
+#ifdef HAVE_ETH_P_8021AD
 				if (vp_admin->vlan_proto != htons(ETH_P_8021AD) ||
 				    slave_state->vst_qinq_supported) {
+#endif
 					vp_oper->state.vlan_proto   = vp_admin->vlan_proto;
 					vp_oper->state.default_vlan = vp_admin->default_vlan;
 					vp_oper->state.default_qos  = vp_admin->default_qos;
+#ifdef HAVE_ETH_P_8021AD
 				}
-
+#endif
 
 				mlx4_dbg((&(priv->dev)), "alloc vlan %d idx  %d slave %d port %d\n",
 					 (int)(vp_oper->state.default_vlan),
@@ -2835,13 +2840,20 @@ struct mlx4_cmd_mailbox *mlx4_alloc_cmd_
 	if (!mailbox)
 		return ERR_PTR(-ENOMEM);
 
+#ifndef HAVE_PCI_POOL_ZALLOC
+	mailbox->buf = pci_pool_alloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,
+#else
 	mailbox->buf = pci_pool_zalloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,
+#endif
 				       &mailbox->dma);
 	if (!mailbox->buf) {
 		kfree(mailbox);
 		return ERR_PTR(-ENOMEM);
 	}
 
+#ifndef HAVE_PCI_POOL_ZALLOC
+	memset(mailbox->buf, 0, MLX4_MAILBOX_SIZE);
+#endif
 	return mailbox;
 }
 EXPORT_SYMBOL_GPL(mlx4_alloc_cmd_mailbox);
@@ -3137,7 +3149,9 @@ int mlx4_set_vf_vlan(struct mlx4_dev *de
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
 	struct mlx4_vport_state *vf_admin;
+#ifdef HAVE_ETH_P_8021AD
 	struct mlx4_slave_state *slave_state;
+#endif
 	struct mlx4_vport_oper_state *vf_oper;
 	int slave;
 
@@ -3148,6 +3162,7 @@ int mlx4_set_vf_vlan(struct mlx4_dev *de
 	if ((vlan > 4095) || (qos > 7))
 		return -EINVAL;
 
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 	if (proto == htons(ETH_P_8021AD) &&
 	    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP))
 		return -EPROTONOSUPPORT;
@@ -3159,17 +3174,23 @@ int mlx4_set_vf_vlan(struct mlx4_dev *de
 	if ((proto == htons(ETH_P_8021AD)) &&
 	    ((vlan == 0) || (vlan == MLX4_VGT)))
 		return -EINVAL;
+#else
+	if (proto != htons(ETH_P_8021Q))
+		return -EPROTONOSUPPORT;
+#endif
 
 	slave = mlx4_get_slave_indx(dev, vf);
 	if (slave < 0)
 		return -EINVAL;
 
+#ifdef HAVE_ETH_P_8021AD
 	slave_state = &priv->mfunc.master.slave_state[slave];
 	if ((proto == htons(ETH_P_8021AD)) && (slave_state->active) &&
 	    (!slave_state->vst_qinq_supported)) {
 		mlx4_err(dev, "vf %d does not support VST QinQ mode\n", vf);
 		return -EPROTONOSUPPORT;
 	}
+#endif
 	port = mlx4_slaves_closest_port(dev, slave, port);
 	vf_admin = &priv->mfunc.master.vf_admin[slave].vport[port];
 	vf_oper = &priv->mfunc.master.vf_oper[slave].vport[port];
@@ -3201,9 +3222,13 @@ int mlx4_set_vf_vlan(struct mlx4_dev *de
 	/* Try to activate new vf state without restart,
 	 * this option is not supported while moving to VST QinQ mode.
 	 */
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 	if ((proto == htons(ETH_P_8021AD) &&
 	     vf_oper->state.vlan_proto != proto) ||
 	    mlx4_master_immediate_activate_vlan_qos(priv, slave, port))
+#else
+	if (mlx4_master_immediate_activate_vlan_qos(priv, slave, port))
+#endif
 		mlx4_info(dev,
 			  "updating vf %d port %d config will take effect on next VF restart\n",
 			  vf, port);
@@ -3355,16 +3380,31 @@ int mlx4_get_vf_config(struct mlx4_dev *
 
 	ivf->vlan		= s_info->default_vlan;
 	ivf->qos		= s_info->default_qos;
+#ifdef HAVE_VF_VLAN_PROTO
 	ivf->vlan_proto		= s_info->vlan_proto;
+#endif
 
+#ifdef HAVE_TX_RATE_LIMIT
 	if (mlx4_is_vf_vst_and_prio_qos(dev, port, s_info))
 		ivf->max_tx_rate = s_info->tx_rate;
 	else
 		ivf->max_tx_rate = 0;
 
 	ivf->min_tx_rate	= 0;
+#else
+#ifdef HAVE_VF_TX_RATE
+	if (mlx4_is_vf_vst_and_prio_qos(dev, port, s_info))
+		ivf->tx_rate = s_info->tx_rate;
+	else
+		ivf->tx_rate = 0;
+#endif
+#endif
+#ifdef HAVE_VF_INFO_SPOOFCHK
 	ivf->spoofchk		= s_info->spoofchk;
+#endif
+#ifdef HAVE_LINKSTATE
 	ivf->linkstate		= s_info->link_state;
+#endif
 
 	return 0;
 }
@@ -3873,3 +3913,35 @@ ssize_t mlx4_get_vf_rate(struct mlx4_dev
 	return len;
 }
 EXPORT_SYMBOL_GPL(mlx4_get_vf_rate);
+
+#if (defined(HAVE_NETIF_F_HW_VLAN_STAG_RX) && !defined(HAVE_VF_VLAN_PROTO))
+ssize_t mlx4_get_vf_vlan_info(struct mlx4_dev *dev, int port, int vf, char *buf)
+{
+	int slave;
+	ssize_t len = 0;
+	struct mlx4_vport_state *s_info;
+	struct mlx4_priv *priv = mlx4_priv(dev);
+
+	if (!mlx4_is_master(dev) ||
+	    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP))
+		return -EOPNOTSUPP;
+
+	slave = mlx4_get_slave_indx(dev, vf);
+	if (slave < 0)
+		return -EINVAL;
+
+	s_info = &priv->mfunc.master.vf_admin[slave].vport[port];
+	if (s_info->default_vlan)
+		len += sprintf(&buf[len], "vlan %d", s_info->default_vlan);
+	if (s_info->default_qos)
+		len += sprintf(&buf[len], ", qos %d", s_info->default_qos);
+	if (s_info->vlan_proto == htons(ETH_P_8021AD))
+		len += sprintf(&buf[len], ", vlan protocol 802.1ad");
+	else if (s_info->default_vlan != MLX4_VGT)
+		len += sprintf(&buf[len], ", vlan protocol 802.1Q");
+	len += sprintf(&buf[len], "\n");
+
+      return len;
+}
+EXPORT_SYMBOL_GPL(mlx4_get_vf_vlan_info);
+#endif
--- a/drivers/net/ethernet/mellanox/mlx4/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c
@@ -211,7 +211,12 @@ static void slave_event(struct mlx4_dev
 	memcpy(s_eqe, eqe, sizeof(struct mlx4_eqe) - 1);
 	s_eqe->slave_id = slave;
 	/* ensure all information is written before setting the ownersip bit */
+
+#ifdef dma_wmb
 	dma_wmb();
+#else
+	wmb();
+#endif
 	s_eqe->owner = !!(slave_eq->prod & SLAVE_EVENT_EQ_SIZE) ? 0x0 : 0x80;
 	++slave_eq->prod;
 
@@ -513,7 +518,11 @@ static int mlx4_eq_int(struct mlx4_dev *
 		 * Make sure we read EQ entry contents after we've
 		 * checked the ownership bit.
 		 */
+#ifdef dma_rmb
 		dma_rmb();
+#else
+		rmb();
+#endif
 
 		switch (eqe->type) {
 		case MLX4_EVENT_TYPE_COMP:
--- a/drivers/net/ethernet/mellanox/mlx4/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c
@@ -308,9 +308,11 @@ static int mlx4_handle_vst_qinq(struct m
 	vp_admin = &priv->mfunc.master.vf_admin[slave].vport[port];
 	slave_state = &priv->mfunc.master.slave_state[slave];
 
+#ifdef HAVE_ETH_P_8021AD
 	if ((vp_admin->vlan_proto != htons(ETH_P_8021AD)) ||
 	    (!slave_state->active))
 		return 0;
+#endif
 
 	if (vp_oper->state.vlan_proto == vp_admin->vlan_proto &&
 	    vp_oper->state.default_vlan == vp_admin->default_vlan &&
@@ -407,7 +409,9 @@ int mlx4_QUERY_FUNC_CAP_wrapper(struct m
 			mlx4_get_active_ports(dev, slave);
 		int converted_port = mlx4_slave_convert_port(
 				dev, slave, vhcr->in_modifier);
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 		struct mlx4_vport_oper_state *vp_oper;
+#endif
 
 		if (converted_port < 0)
 			return -EINVAL;
@@ -448,7 +452,9 @@ int mlx4_QUERY_FUNC_CAP_wrapper(struct m
 		MLX4_PUT(outbox->buf, dev->caps.phys_port_id[vhcr->in_modifier],
 			 QUERY_FUNC_CAP_PHYS_PORT_ID);
 
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 		vp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];
+#endif
 		err = mlx4_handle_vst_qinq(priv, slave, port);
 		if (err)
 			return err;
@@ -456,8 +462,10 @@ int mlx4_QUERY_FUNC_CAP_wrapper(struct m
 		field = 0;
 		if (dev->caps.phv_bit[port])
 			field |= QUERY_FUNC_CAP_PHV_BIT;
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 		if (vp_oper->state.vlan_proto == htons(ETH_P_8021AD))
 			field |= QUERY_FUNC_CAP_VLAN_OFFLOAD_DISABLE;
+#endif
 		MLX4_PUT(outbox->buf, field, QUERY_FUNC_CAP_FLAGS0_OFFSET);
 
 	} else if (vhcr->op_modifier == 0) {
@@ -974,10 +982,11 @@ int mlx4_QUERY_DEV_CAP(struct mlx4_dev *
 	dev_cap->max_sq_sg = field;
 	MLX4_GET(size, outbox, QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET);
 	dev_cap->max_sq_desc_sz = size;
-
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_SVLAN_BY_QP_OFFSET);
 	if (field & 0x1)
 		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP;
+#endif
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_MAX_QP_MCG_OFFSET);
 	dev_cap->max_qp_per_mcg = 1 << field;
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_RSVD_MCG_OFFSET);
@@ -3187,6 +3196,7 @@ int set_phv_bit(struct mlx4_dev *dev, u8
 }
 EXPORT_SYMBOL(set_phv_bit);
 
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 int mlx4_get_is_vlan_offload_disabled(struct mlx4_dev *dev, u8 port,
 				      bool *vlan_offload_disabled)
 {
@@ -3202,6 +3212,7 @@ int mlx4_get_is_vlan_offload_disabled(st
 	return err;
 }
 EXPORT_SYMBOL(mlx4_get_is_vlan_offload_disabled);
+#endif
 
 void mlx4_replace_zero_macs(struct mlx4_dev *dev)
 {
--- a/drivers/net/ethernet/mellanox/mlx4/intf.c
+++ b/drivers/net/ethernet/mellanox/mlx4/intf.c
@@ -34,7 +34,9 @@
 #include <linux/slab.h>
 #include <linux/export.h>
 #include <linux/errno.h>
+#ifdef HAVE_DEVLINK_H
 #include <net/devlink.h>
+#endif
 
 #include "mlx4.h"
 
@@ -266,6 +268,7 @@ void *mlx4_get_protocol_dev(struct mlx4_
 }
 EXPORT_SYMBOL_GPL(mlx4_get_protocol_dev);
 
+#ifdef HAVE_DEVLINK_H
 struct devlink_port *mlx4_get_devlink_port(struct mlx4_dev *dev, int port)
 {
 	struct mlx4_port_info *info = &mlx4_priv(dev)->port[port];
@@ -273,3 +276,4 @@ struct devlink_port *mlx4_get_devlink_po
 	return &info->devlink_port;
 }
 EXPORT_SYMBOL_GPL(mlx4_get_devlink_port);
+#endif
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@ -44,7 +44,9 @@
 #include <linux/delay.h>
 #include <linux/kmod.h>
 #include <linux/etherdevice.h>
+#ifdef HAVE_DEVLINK_H
 #include <net/devlink.h>
+#endif
 
 #include <linux/mlx4/device.h>
 #include <linux/mlx4/doorbell.h>
@@ -3692,6 +3694,9 @@ static void mlx4_enable_msi_x(struct mlx
 	struct msix_entry *entries;
 	int i;
 	int port = 0;
+#ifndef HAVE_PCI_ENABLE_MSIX_RANGE
+	int err;
+#endif
 
 	if (msi_x) {
 		int nreq = dev->caps.num_ports * num_online_cpus() + 1;
@@ -3714,8 +3719,24 @@ static void mlx4_enable_msi_x(struct mlx
 		for (i = 0; i < nreq; ++i)
 			entries[i].entry = i;
 
+#ifdef HAVE_PCI_ENABLE_MSIX_RANGE
 		nreq = pci_enable_msix_range(dev->persist->pdev, entries, 2,
 					     nreq);
+#else
+retry:
+		err = pci_enable_msix(dev->persist->pdev, entries, nreq);
+		if (err) {
+			/* Try again if at least 2 vectors are available */
+			if (err > 1) {
+				mlx4_info(dev, "Requested %d vectors, "
+					  "but only %d MSI-X vectors available, "
+					  "trying again\n", nreq, err);
+				nreq = err;
+				goto retry;
+			}
+			nreq = -1;
+		}
+#endif
 
 		/* At least 2 vectors are required, one for the ASYNC EQ and
 		 * a completion EQ.
@@ -3791,13 +3812,17 @@ no_msi:
 
 static int mlx4_init_port_info(struct mlx4_dev *dev, int port)
 {
+#ifdef HAVE_DEVLINK_H
 	struct devlink *devlink = priv_to_devlink(mlx4_priv(dev));
+#endif
 	struct mlx4_port_info *info = &mlx4_priv(dev)->port[port];
 	int err;
 
+#ifdef HAVE_DEVLINK_H
 	err = devlink_port_register(devlink, &info->devlink_port, port);
 	if (err)
 		return err;
+#endif
 
 	info->dev = dev;
 	info->port = port;
@@ -3824,7 +3849,9 @@ static int mlx4_init_port_info(struct ml
 	err = device_create_file(&dev->persist->pdev->dev, &info->port_attr);
 	if (err) {
 		mlx4_err(dev, "Failed to create file for port %d\n", port);
+#ifdef HAVE_DEVLINK_H
 		devlink_port_unregister(&info->devlink_port);
+#endif
 		info->port = -1;
 	}
 
@@ -3845,7 +3872,9 @@ static int mlx4_init_port_info(struct ml
 		mlx4_err(dev, "Failed to create mtu file for port %d\n", port);
 		device_remove_file(&info->dev->persist->pdev->dev,
 				   &info->port_attr);
+#ifdef HAVE_DEVLINK_H
 		devlink_port_unregister(&info->devlink_port);
+#endif
 		info->port = -1;
 	}
 
@@ -3860,7 +3889,9 @@ static void mlx4_cleanup_port_info(struc
 	device_remove_file(&info->dev->persist->pdev->dev, &info->port_attr);
 	device_remove_file(&info->dev->persist->pdev->dev,
 			   &info->port_mtu_attr);
+#ifdef HAVE_DEVLINK_H
 	devlink_port_unregister(&info->devlink_port);
+#endif
 
 #ifdef CONFIG_RFS_ACCEL
 	free_irq_cpu_rmap(info->rmap);
@@ -4665,6 +4696,7 @@ err_disable_pdev:
 	return err;
 }
 
+#ifdef HAVE_DEVLINK_H
 static int mlx4_devlink_port_type_set(struct devlink_port *devlink_port,
 				      enum devlink_port_type port_type)
 {
@@ -4693,26 +4725,40 @@ static int mlx4_devlink_port_type_set(st
 static const struct devlink_ops mlx4_devlink_ops = {
 	.port_type_set	= mlx4_devlink_port_type_set,
 };
+#endif
 
 static int mlx4_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
+#ifdef HAVE_DEVLINK_H
 	struct devlink *devlink;
+#endif
 	struct mlx4_priv *priv;
 	struct mlx4_dev *dev;
 	int ret;
 
 	printk_once(KERN_INFO "%s", mlx4_version);
 
+#ifdef HAVE_DEVLINK_H
 	devlink = devlink_alloc(&mlx4_devlink_ops, sizeof(*priv));
 	if (!devlink)
 		return -ENOMEM;
 	priv = devlink_priv(devlink);
+#else
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+#endif
 
 	dev       = &priv->dev;
 	dev->persist = kzalloc(sizeof(*dev->persist), GFP_KERNEL);
 	if (!dev->persist) {
+#ifdef HAVE_DEVLINK_H
 		ret = -ENOMEM;
 		goto err_devlink_free;
+#else
+		kfree(priv);
+		return -ENOMEM;
+#endif
 	}
 	dev->persist->pdev = pdev;
 	dev->persist->dev = dev;
@@ -4722,23 +4768,35 @@ static int mlx4_init_one(struct pci_dev
 	mutex_init(&dev->persist->interface_state_mutex);
 	mutex_init(&dev->persist->pci_status_mutex);
 
+#ifdef HAVE_DEVLINK_H
 	ret = devlink_register(devlink, &pdev->dev);
 	if (ret)
 		goto err_persist_free;
+#endif
 
 	ret =  __mlx4_init_one(pdev, id->driver_data, priv);
+#ifdef HAVE_DEVLINK_H
 	if (ret)
 		goto err_devlink_unregister;
-
 	pci_save_state(pdev);
 	return 0;
+#else
+	if (ret) {
+		kfree(dev->persist);
+		kfree(priv);
+	} else {
+		pci_save_state(pdev);
+	}
+#endif
 
+#ifdef HAVE_DEVLINK_H
 err_devlink_unregister:
 	devlink_unregister(devlink);
 err_persist_free:
 	kfree(dev->persist);
 err_devlink_free:
 	devlink_free(devlink);
+#endif
 	return ret;
 }
 
@@ -4839,7 +4897,9 @@ static void mlx4_remove_one(struct pci_d
 	struct mlx4_dev_persistent *persist = pci_get_drvdata(pdev);
 	struct mlx4_dev  *dev  = persist->dev;
 	struct mlx4_priv *priv = mlx4_priv(dev);
+#ifdef HAVE_DEVLINK_H
 	struct devlink *devlink = priv_to_devlink(priv);
+#endif
 	int active_vfs = 0;
 
 	if (mlx4_is_slave(dev))
@@ -4873,9 +4933,15 @@ static void mlx4_remove_one(struct pci_d
 
 	pci_release_regions(pdev);
 	mlx4_pci_disable_device(dev);
+#ifdef HAVE_DEVLINK_H
 	devlink_unregister(devlink);
+#endif
 	kfree(dev->persist);
+#ifdef HAVE_DEVLINK_H
 	devlink_free(devlink);
+#else
+	kfree(priv);
+#endif
 	pci_set_drvdata(pdev, NULL);
 }
 
@@ -5061,7 +5127,11 @@ static void mlx4_shutdown(struct pci_dev
 	mutex_unlock(&persist->interface_state_mutex);
 }
 
+#ifdef CONFIG_COMPAT_IS_CONST_PCI_ERROR_HANDLERS
 static const struct pci_error_handlers mlx4_err_handler = {
+#else
+static struct pci_error_handlers mlx4_err_handler = {
+#endif
 	.error_detected = mlx4_pci_err_detected,
 	.slot_reset     = mlx4_pci_slot_reset,
 	.resume		= mlx4_pci_resume,
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
@@ -45,7 +45,9 @@
 #include <linux/workqueue.h>
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
+#ifdef HAVE_DEVLINK_H
 #include <net/devlink.h>
+#endif
 #include <linux/rwsem.h>
 
 #include <linux/mlx4/device.h>
@@ -862,7 +864,9 @@ struct mlx4_port_info {
 	struct mlx4_roce_info	roce;
 	int			base_qpn;
 	struct cpu_rmap		*rmap;
+#ifdef HAVE_DEVLINK_H
 	struct devlink_port	devlink_port;
+#endif
 };
 
 struct mlx4_sense {
--- a/drivers/net/ethernet/mellanox/mlx4/pd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/pd.c
@@ -205,9 +205,15 @@ int mlx4_bf_alloc(struct mlx4_dev *dev,
 			goto free_uar;
 		}
 
+#ifdef HAVE_IO_MAPPING_MAP_WC_3_PARAMS
 		uar->bf_map = io_mapping_map_wc(priv->bf_mapping,
 						uar->index << PAGE_SHIFT,
 						PAGE_SIZE);
+#else
+		uar->bf_map = io_mapping_map_wc(priv->bf_mapping,
+						uar->index << PAGE_SHIFT);
+#endif
+
 		if (!uar->bf_map) {
 			err = -ENOMEM;
 			goto unamp_uar;
--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
@@ -802,6 +802,7 @@ static int update_vport_qp_param(struct
 				MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED |
 				MLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED;
 		} else if (0 != vp_oper->state.default_vlan) {
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 			if (vp_oper->state.vlan_proto == htons(ETH_P_8021AD)) {
 				/* vst QinQ should block untagged on TX,
 				 * but cvlan is in payload and phv is set so
@@ -813,11 +814,14 @@ static int update_vport_qp_param(struct
 					MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |
 					MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED;
 			} else { /* vst 802.1Q */
+#endif
 				qpc->pri_path.vlan_control |=
 					MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |
 					MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |
 					MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED;
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 			}
+#endif
 		} else { /* priority tagged */
 			qpc->pri_path.vlan_control |=
 				MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |
@@ -826,9 +830,11 @@ static int update_vport_qp_param(struct
 
 		qpc->pri_path.vlan_index = vp_oper->vlan_idx;
 		qpc->pri_path.fl |= MLX4_FL_ETH_HIDE_CQE_VLAN;
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 		if (vp_oper->state.vlan_proto == htons(ETH_P_8021AD))
 			qpc->pri_path.fl |= MLX4_FL_SV;
 		else
+#endif
 			qpc->pri_path.fl |= MLX4_FL_CV;
 		qpc->pri_path.feup |= MLX4_FEUP_FORCE_ETH_UP | MLX4_FVL_FORCE_ETH_VLAN | MLX4_FVL_RX_FORCE_ETH_VLAN;
 		qpc->pri_path.sched_queue &= 0xC7;
@@ -5729,11 +5735,13 @@ void mlx4_vf_immed_vlan_work_handler(str
 	else if (!work->vlan_id)
 		vlan_control = MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |
 			MLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED;
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 	else if (work->vlan_proto == htons(ETH_P_8021AD))
 		vlan_control = MLX4_VLAN_CTRL_ETH_TX_BLOCK_PRIO_TAGGED |
 			MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |
 			MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |
 			MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED;
+#endif
 	else  /* vst 802.1Q */
 		vlan_control = MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |
 			MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |
@@ -5777,9 +5785,11 @@ void mlx4_vf_immed_vlan_work_handler(str
 				upd_context->qp_context.pri_path.vlan_index = work->vlan_ix;
 				upd_context->qp_context.pri_path.fl =
 					qp->pri_path_fl | MLX4_FL_ETH_HIDE_CQE_VLAN;
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 				if (work->vlan_proto == htons(ETH_P_8021AD))
 					upd_context->qp_context.pri_path.fl |= MLX4_FL_SV;
 				else
+#endif
 					upd_context->qp_context.pri_path.fl |= MLX4_FL_CV;
 				upd_context->qp_context.pri_path.feup =
 					qp->feup | MLX4_FEUP_FORCE_ETH_UP | MLX4_FVL_FORCE_ETH_VLAN | MLX4_FVL_RX_FORCE_ETH_VLAN;
--- a/include/linux/mlx4/cmd.h
+++ b/include/linux/mlx4/cmd.h
@@ -340,6 +340,9 @@ int mlx4_config_dev_retrieval(struct mlx
 void mlx4_cmd_wake_completions(struct mlx4_dev *dev);
 void mlx4_report_internal_err_comm_event(struct mlx4_dev *dev);
 ssize_t mlx4_get_vf_rate(struct mlx4_dev *dev, int port, int vf, char *buf);
+#if (defined(HAVE_NETIF_F_HW_VLAN_STAG_RX) && !defined(HAVE_VF_VLAN_PROTO))
+ssize_t mlx4_get_vf_vlan_info(struct mlx4_dev *dev, int port, int vf, char *buf);
+#endif
 /*
  * mlx4_get_slave_default_vlan -
  * return true if VST ( default vlan)
--- a/include/linux/mlx4/cq.h
+++ b/include/linux/mlx4/cq.h
@@ -34,7 +34,11 @@
 #define MLX4_CQ_H
 
 #include <linux/types.h>
+#ifdef HAVE_UAPI_LINUX_IF_ETHER_H
 #include <uapi/linux/if_ether.h>
+#else
+#include <linux/if_ether.h>
+#endif
 
 #include <linux/mlx4/device.h>
 #include <linux/mlx4/doorbell.h>
--- a/include/linux/mlx4/cq_exp.h
+++ b/include/linux/mlx4/cq_exp.h
@@ -2,7 +2,9 @@
 #define MLX4_CQ_EXP_H
 
 #include <linux/types.h>
+#ifdef HAVE_UAPI_LINUX_IF_ETHER_H
 #include <uapi/linux/if_ether.h>
+#endif
 
 #include <linux/mlx4/device.h>
 #include <linux/mlx4/doorbell.h>
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@ -37,12 +37,17 @@
 #include <linux/pci.h>
 #include <linux/completion.h>
 #include <linux/radix-tree.h>
+#ifdef HAVE_NETDEV_RX_CPU_RMAP
 #include <linux/cpu_rmap.h>
+#endif
 #include <linux/crash_dump.h>
 
 #include <linux/atomic.h>
-
+#ifdef HAVE_TIMECOUNTER_H
 #include <linux/timecounter.h>
+#else
+#include <linux/clocksource.h>
+#endif
 
 #define DEFAULT_UAR_PAGE_SHIFT  12
 
@@ -1578,8 +1583,10 @@ int mlx4_SET_PORT_disable_mc_loopback(st
 				      bool disable_mc_loopback);
 int set_phv_bit(struct mlx4_dev *dev, u8 port, int new_val);
 int get_phv_bit(struct mlx4_dev *dev, u8 port, int *phv);
+#ifdef HAVE_NETIF_F_HW_VLAN_STAG_RX
 int mlx4_get_is_vlan_offload_disabled(struct mlx4_dev *dev, u8 port,
 				      bool *vlan_offload_disabled);
+#endif
 void mlx4_handle_eth_header_mcast_prio(struct mlx4_net_trans_rule_hw_ctrl *ctrl,
 				       struct _rule_hw *eth_header);
 int mlx4_find_cached_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *idx);
--- a/include/linux/mlx4/driver.h
+++ b/include/linux/mlx4/driver.h
@@ -33,7 +33,9 @@
 #ifndef MLX4_DRIVER_H
 #define MLX4_DRIVER_H
 
+#ifdef HAVE_DEVLINK_H
 #include <net/devlink.h>
+#endif
 #include <linux/mlx4/device.h>
 
 struct mlx4_dev;
@@ -146,7 +148,9 @@ int mlx4_port_map_set(struct mlx4_dev *d
 
 void *mlx4_get_protocol_dev(struct mlx4_dev *dev, enum mlx4_protocol proto, int port);
 
+#ifdef HAVE_DEVLINK_H
 struct devlink_port *mlx4_get_devlink_port(struct mlx4_dev *dev, int port);
+#endif
 
 static inline u64 mlx4_mac_to_u64(u8 *addr)
 {
