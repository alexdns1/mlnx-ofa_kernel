From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/main.c

Change-Id: Idb0a45d5204e77e86093f0d9adf4212282a6ac3a
---
 .../net/ethernet/mellanox/mlx5/core/main.c    | 42 ++++++++++++++++---
 1 file changed, 36 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -337,8 +337,14 @@ static void mlx5_set_driver_version(stru
 	remaining_size = max_t(int, 0, driver_ver_sz - strlen(string));
 
 	snprintf(string + strlen(string), remaining_size, "%u.%u.%u",
+#ifdef LINUX_VERSION_MAJOR
 		LINUX_VERSION_MAJOR, LINUX_VERSION_PATCHLEVEL,
 		LINUX_VERSION_SUBLEVEL);
+#else
+		(u8)((LINUX_VERSION_CODE >> 16) & 0xff), (u8)((LINUX_VERSION_CODE >> 8) & 0xff),
+		(u16)(LINUX_VERSION_CODE & 0xffff));
+#endif
+
 
 	/*Send the command*/
 	MLX5_SET(set_driver_version_in, in, opcode,
@@ -731,10 +737,11 @@ static int handle_hca_cap(struct mlx5_co
 		MLX5_SET(cmd_hca_cap, set_hca_cap, mkey_by_name, 1);
 
 	mlx5_vhca_state_cap_handle(dev, set_hca_cap);
-
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 	if (MLX5_CAP_GEN_MAX(dev, num_total_dynamic_vf_msix))
 		MLX5_SET(cmd_hca_cap, set_hca_cap, num_total_dynamic_vf_msix,
 			 MLX5_CAP_GEN_MAX(dev, num_total_dynamic_vf_msix));
+#endif
 
 	return set_caps(dev, set_ctx, MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE);
 }
@@ -949,8 +956,11 @@ static ssize_t mlx5_roce_enable_set_enab
 {
 	struct pci_dev *pdev = container_of(device, struct pci_dev, dev);
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
 	struct devlink *devlink = priv_to_devlink(dev);
 	union devlink_param_value value;
+#endif
+	bool change;
 	int ret;
 	bool val;
 
@@ -962,13 +972,22 @@ static ssize_t mlx5_roce_enable_set_enab
 		return -EOPNOTSUPP;
 
 	mutex_lock(&dev->roce.state_lock);
+	change = dev->roce.enabled != val;
 	dev->roce.enabled = val;
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
 	value.vbool = val;
 	devlink_param_driverinit_value_set(devlink,
 			DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,
 			value);
+#endif
 	mutex_unlock(&dev->roce.state_lock);
+#if !defined(HAVE_DEVLINK_HAS_RELOAD) && !defined(HAVE_DEVLINK_HAS_RELOAD_UP_DOWN)
+	if (!change)
+		return count;
 
+	mlx5_unload_one(dev);
+	return mlx5_load_one(dev);
+#endif
 	return count;
 }
 
@@ -1421,12 +1440,13 @@ static int mlx5_load(struct mlx5_core_de
 
 	mlx5_accel_ipsec_init(dev);
 
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	err = mlx5_accel_tls_init(dev);
 	if (err) {
 		mlx5_core_err(dev, "TLS device start failed %d\n", err);
 		goto err_tls_start;
 	}
-
+#endif
 	err = mlx5_init_fs(dev);
 	if (err) {
 		mlx5_core_err(dev, "Failed to init flow steering\n");
@@ -1477,8 +1497,10 @@ err_vhca:
 err_set_hca:
 	mlx5_cleanup_fs(dev);
 err_fs:
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	mlx5_accel_tls_cleanup(dev);
 err_tls_start:
+#endif
 	mlx5_accel_ipsec_cleanup(dev);
 	mlx5_fpga_device_stop(dev);
 err_fpga_start:
@@ -1509,7 +1531,9 @@ static void mlx5_unload(struct mlx5_core
 	mlx5_vhca_event_stop(dev);
 	mlx5_cleanup_fs(dev);
 	mlx5_accel_ipsec_cleanup(dev);
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	mlx5_accel_tls_cleanup(dev);
+#endif
 	mlx5_fpga_device_stop(dev);
 	mlx5_rsc_dump_cleanup(dev);
 	mlx5_hv_vhca_cleanup(dev->hv_vhca);
@@ -1875,12 +1899,12 @@ void mlx5_mdev_uninit(struct mlx5_core_d
 
 static int probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
-	struct mlx5_core_dev *dev;
+	struct mlx5_core_dev *dev = NULL;
 	struct devlink *devlink;
 	struct mlx5_priv *priv;
 	int err;
 
-	devlink = mlx5_devlink_alloc();
+	devlink = mlx5_devlink_alloc(&pdev->dev);
 	if (!devlink) {
 		dev_err(&pdev->dev, "devlink alloc failed\n");
 		return -ENOMEM;
@@ -1943,8 +1967,10 @@ static int probe_one(struct pci_dev *pde
 		dev_err(&pdev->dev, "mlx5_crdump_enable failed with error code %d\n", err);
 
 	pci_save_state(pdev);
-	if (!mlx5_core_is_mp_slave(dev))
-		devlink_reload_enable(devlink);
+#ifdef HAVE_DEVLINK_RELOAD_ENABLE
+       if (!mlx5_core_is_mp_slave(dev))
+       	devlink_reload_enable(devlink);
+#endif
 	return 0;
 
 err_init_one:
@@ -1980,7 +2006,9 @@ static void remove_one(struct pci_dev *p
 	if (mlx5_try_fast_unload(dev))
 		dev_dbg(&dev->pdev->dev, "mlx5_try_fast_unload failed\n");
 
+#ifdef HAVE_DEVLINK_RELOAD_DISABLE
 	devlink_reload_disable(devlink);
+#endif
 	mlx5_crdump_disable(dev);
 	mlx5_drain_health_wq(dev);
 	mlx5_uninit_one(dev);
@@ -2273,8 +2301,10 @@ static struct pci_driver mlx5_core_drive
 	.shutdown	= shutdown,
 	.err_handler	= &mlx5_err_handler,
 	.sriov_configure   = mlx5_core_sriov_configure,
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 	.sriov_get_vf_total_msix = mlx5_sriov_get_vf_total_msix,
 	.sriov_set_msix_vec_count = mlx5_core_sriov_set_msix_vec_count,
+#endif
 };
 
 static void mlx5_core_verify_params(void)
