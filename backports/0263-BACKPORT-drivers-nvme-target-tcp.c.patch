From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/nvme/target/tcp.c

Change-Id: I76919c53f32485e22b1728756f79e3aa633259b2
---
 drivers/nvme/target/tcp.c | 59 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 55 insertions(+), 4 deletions(-)

--- a/drivers/nvme/target/tcp.c
+++ b/drivers/nvme/target/tcp.c
@@ -3,6 +3,9 @@
  * NVMe over Fabrics TCP target.
  * Copyright (c) 2018 Lightbits Labs. All rights reserved.
  */
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 #include <linux/module.h>
 #include <linux/init.h>
@@ -321,18 +324,26 @@ static void nvmet_tcp_build_pdu_iovec(st
 
 	while (length) {
 		u32 iov_len = min_t(u32, length, sg->length - sg_offset);
-
+#ifdef HAVE_BVEC_SET_PAGE
 		bvec_set_page(iov, sg_page(sg), sg->length,
 				sg->offset + sg_offset);
-
+#else
+		iov->bv_page = sg_page(sg);
+		iov->bv_len = sg->length;
+		iov->bv_offset = sg->offset + sg_offset;
+#endif
 		length -= iov_len;
 		sg = sg_next(sg);
 		iov++;
 		sg_offset = 0;
 	}
-
+#ifdef HAVE_ITER_DEST
 	iov_iter_bvec(&cmd->recv_msg.msg_iter, ITER_DEST, cmd->iov,
 		      nr_pages, cmd->pdu_len);
+#else
+	iov_iter_bvec(&cmd->recv_msg.msg_iter, READ, cmd->iov,
+		      nr_pages, cmd->pdu_len);
+#endif
 }
 
 static void nvmet_tcp_fatal_error(struct nvmet_tcp_queue *queue)
@@ -1470,7 +1481,9 @@ static void nvmet_tcp_data_ready(struct
 {
 	struct nvmet_tcp_queue *queue;
 
+#ifdef HAVE_TRACE_EVENTS_TRACE_SK_DATA_READY
 	trace_sk_data_ready(sk);
+#endif
 
 	read_lock_bh(&sk->sk_callback_lock);
 	queue = sk->sk_user_data;
@@ -1533,14 +1546,27 @@ static int nvmet_tcp_set_queue_sock(stru
 	struct socket *sock = queue->sock;
 	struct inet_sock *inet = inet_sk(sock->sk);
 	int ret;
+#ifndef HAVE_KERNEL_GETSOCKNAME_2_PARAMS
+	int len;
+#endif
 
+#ifdef HAVE_KERNEL_GETSOCKNAME_2_PARAMS
 	ret = kernel_getsockname(sock,
 		(struct sockaddr *)&queue->sockaddr);
+#else
+	ret = kernel_getsockname(sock,
+		(struct sockaddr *)&queue->sockaddr, &len);
+#endif
 	if (ret < 0)
 		return ret;
 
+#ifdef HAVE_KERNEL_GETSOCKNAME_2_PARAMS
 	ret = kernel_getpeername(sock,
 		(struct sockaddr *)&queue->sockaddr_peer);
+#else
+	ret = kernel_getpeername(sock,
+		(struct sockaddr *)&queue->sockaddr_peer, &len);
+#endif
 	if (ret < 0)
 		return ret;
 
@@ -1555,8 +1581,19 @@ static int nvmet_tcp_set_queue_sock(stru
 		sock_set_priority(sock->sk, so_priority);
 
 	/* Set socket type of service */
+#ifdef HAVE_IP_SOCK_SET_TOS
 	if (inet->rcv_tos > 0)
 		ip_sock_set_tos(sock->sk, inet->rcv_tos);
+#else
+	if (inet->rcv_tos > 0) {
+		int tos = inet->rcv_tos;
+
+		ret = kernel_setsockopt(sock, SOL_IP, IP_TOS,
+			(char *)&tos, sizeof(tos));
+		if (ret)
+			return ret;
+	}
+#endif
 
 	ret = 0;
 	write_lock_bh(&sock->sk->sk_callback_lock);
@@ -1669,8 +1706,9 @@ static void nvmet_tcp_listen_data_ready(
 {
 	struct nvmet_tcp_port *port;
 
+#ifdef HAVE_TRACE_EVENTS_TRACE_SK_DATA_READY
 	trace_sk_data_ready(sk);
-
+#endif
 	read_lock_bh(&sk->sk_callback_lock);
 	port = sk->sk_user_data;
 	if (!port)
@@ -1687,6 +1725,9 @@ static int nvmet_tcp_add_port(struct nvm
 	struct nvmet_tcp_port *port;
 	__kernel_sa_family_t af;
 	int ret;
+#ifndef HAVE_TCP_SOCK_SET_NODELAY
+	int opt;
+#endif
 
 	port = kzalloc(sizeof(*port), GFP_KERNEL);
 	if (!port)
@@ -1730,7 +1771,17 @@ static int nvmet_tcp_add_port(struct nvm
 	port->data_ready = port->sock->sk->sk_data_ready;
 	port->sock->sk->sk_data_ready = nvmet_tcp_listen_data_ready;
 	sock_set_reuseaddr(port->sock->sk);
+#ifdef HAVE_TCP_SOCK_SET_NODELAY
 	tcp_sock_set_nodelay(port->sock->sk);
+#else
+	opt = 1;
+	ret = kernel_setsockopt(port->sock, IPPROTO_TCP,
+			TCP_NODELAY, (char *)&opt, sizeof(opt));
+	if (ret) {
+		pr_err("failed to set TCP_NODELAY sock opt %d\n", ret);
+		goto err_sock;
+	}
+#endif
 	if (so_priority > 0)
 		sock_set_priority(port->sock->sk, so_priority);
 
