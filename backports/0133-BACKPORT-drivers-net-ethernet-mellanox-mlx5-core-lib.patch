From: Mikhael Goikhman <migo@mellanox.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c

Change-Id: I556e581ab2219471a8d006235516f1b8d079f1a5
---
 drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c
@@ -81,12 +81,13 @@ bool mlx5_vxlan_lookup_port(struct mlx5_
 {
 	struct mlx5_vxlan_port *vxlanp;
 	bool found = false;
+	COMPAT_HL_NODE
 
 	if (!mlx5_vxlan_allowed(vxlan))
 		return NULL;
 
 	rcu_read_lock();
-	hash_for_each_possible_rcu(vxlan->htable, vxlanp, hlist, port)
+	compat_hash_for_each_possible_rcu(vxlan->htable, vxlanp, hlist, port)
 		if (vxlanp->udp_port == port) {
 			found = true;
 			break;
@@ -99,8 +100,9 @@ bool mlx5_vxlan_lookup_port(struct mlx5_
 static struct mlx5_vxlan_port *vxlan_lookup_port(struct mlx5_vxlan *vxlan, u16 port)
 {
 	struct mlx5_vxlan_port *vxlanp;
+	COMPAT_HL_NODE
 
-	hash_for_each_possible(vxlan->htable, vxlanp, hlist, port)
+	compat_hash_for_each_possible(vxlan->htable, vxlanp, hlist, port)
 		if (vxlanp->udp_port == port)
 			return vxlanp;
 	return NULL;
@@ -205,12 +207,13 @@ void mlx5_vxlan_destroy(struct mlx5_vxla
 	struct mlx5_vxlan_port *vxlanp;
 	struct hlist_node *tmp;
 	int bkt;
+	COMPAT_HL_NODE
 
 	if (!mlx5_vxlan_allowed(vxlan))
 		return;
 
 	/* Lockless since we are the only hash table consumers*/
-	hash_for_each_safe(vxlan->htable, bkt, tmp, vxlanp, hlist) {
+	compat_hash_for_each_safe(vxlan->htable, bkt, tmp, vxlanp, hlist) {
 		hash_del(&vxlanp->hlist);
 		mlx5_vxlan_core_del_port_cmd(vxlan->mdev, vxlanp->udp_port);
 		kfree(vxlanp);
