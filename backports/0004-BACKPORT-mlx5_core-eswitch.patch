From: Alaa Hleihel <alaa@mellanox.com>
Subject: [PATCH] BACKPORT: mlx5_core eswitch

Add only mlx5_core eswitch backports to this patch (without core, EN or ipoib).
That is:
- drivers/net/ethernet/mellanox/mlx5/core/eswitch*

Change-Id: I124987060bd7dc95af7bf62e3e7ae31cd1c86ea8
Signed-off-by: Alaa Hleihel <alaa@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx5/core/eswitch.c  | 23 ++++++++++++++++
 drivers/net/ethernet/mellanox/mlx5/core/eswitch.h  | 31 ++++++++++++++++++++--
 .../ethernet/mellanox/mlx5/core/eswitch_offloads.c | 20 ++++++++++++++
 3 files changed, 72 insertions(+), 2 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -469,6 +469,7 @@ static int esw_add_uc_addr(struct mlx5_e
 	u8 *mac = vaddr->node.addr;
 	u32 vport = vaddr->vport;
 	int err;
+	COMPAT_HL_NODE
 
 	esw_uc = l2addr_hash_find(hash, mac, struct esw_uc_addr);
 	if (esw_uc) {
@@ -505,6 +506,7 @@ static int esw_del_uc_addr(struct mlx5_e
 	struct esw_uc_addr *esw_uc;
 	u8 *mac = vaddr->node.addr;
 	u32 vport = vaddr->vport;
+	COMPAT_HL_NODE
 
 	esw_uc = l2addr_hash_find(hash, mac, struct esw_uc_addr);
 	if (!esw_uc || esw_uc->vport != vport) {
@@ -532,6 +534,7 @@ static void update_allmulti_vports(struc
 {
 	u8 *mac = vaddr->node.addr;
 	u32 vport_idx = 0;
+	COMPAT_HL_NODE
 
 	for (vport_idx = 0; vport_idx < esw->total_vports; vport_idx++) {
 		struct mlx5_vport *vport = &esw->vports[vport_idx];
@@ -579,6 +582,7 @@ static int esw_add_mc_addr(struct mlx5_e
 	struct esw_mc_addr *esw_mc;
 	u8 *mac = vaddr->node.addr;
 	u32 vport = vaddr->vport;
+	COMPAT_HL_NODE
 
 	if (!esw->fdb_table.fdb)
 		return 0;
@@ -619,6 +623,7 @@ static int esw_del_mc_addr(struct mlx5_e
 	struct esw_mc_addr *esw_mc;
 	u8 *mac = vaddr->node.addr;
 	u32 vport = vaddr->vport;
+	COMPAT_HL_NODE
 
 	if (!esw->fdb_table.fdb)
 		return 0;
@@ -668,6 +673,7 @@ static void esw_apply_vport_addr_list(st
 	struct hlist_head *hash;
 	struct hlist_node *tmp;
 	int hi;
+	COMPAT_HL_NODE
 
 	vport_addr_add = is_uc ? esw_add_uc_addr :
 				 esw_add_mc_addr;
@@ -705,6 +711,7 @@ static void esw_update_vport_addr_list(s
 	int err;
 	int hi;
 	int i;
+	COMPAT_HL_NODE
 
 	size = is_uc ? MLX5_MAX_UC_PER_VPORT(esw->dev) :
 		       MLX5_MAX_MC_PER_VPORT(esw->dev);
@@ -787,6 +794,7 @@ static void esw_update_vport_mc_promisc(
 	struct hlist_head *hash;
 	struct hlist_node *tmp;
 	int hi;
+	COMPAT_HL_NODE
 
 	hash = vport->mc_list;
 
@@ -1748,6 +1756,9 @@ int mlx5_eswitch_init(struct mlx5_core_d
 		 MLX5_MAX_UC_PER_VPORT(dev),
 		 MLX5_MAX_MC_PER_VPORT(dev));
 
+	/* In RH6.8 and lower pci_sriov_get_totalvfs might return -EINVAL */
+	total_vports = (total_vports < 0) ? 1 : total_vports;
+
 	esw = kzalloc(sizeof(*esw), GFP_KERNEL);
 	if (!esw)
 		return -ENOMEM;
@@ -1790,7 +1801,9 @@ int mlx5_eswitch_init(struct mlx5_core_d
 		goto abort;
 	}
 
+#ifdef HAVE_TCF_TUNNEL_INFO
 	hash_init(esw->offloads.encap_tbl);
+#endif
 	mutex_init(&esw->state_lock);
 
 	access_other_hca_roce = MLX5_CAP_GEN(dev, vhca_group_manager) &&
@@ -2006,13 +2019,23 @@ int mlx5_eswitch_get_vport_config(struct
 
 	mutex_lock(&esw->state_lock);
 	ether_addr_copy(ivi->mac, evport->info.mac);
+#ifdef HAVE_LINKSTATE
 	ivi->linkstate = evport->info.link_state;
+#endif
 	ivi->vlan = evport->info.vlan;
 	ivi->qos = evport->info.qos;
+#ifdef HAVE_VF_INFO_SPOOFCHK
 	ivi->spoofchk = evport->info.spoofchk;
+#endif
+#ifdef HAVE_VF_INFO_TRUST
 	ivi->trusted = evport->info.trusted;
+#endif
+#ifdef HAVE_TX_RATE_LIMIT
 	ivi->min_tx_rate = evport->info.min_rate;
 	ivi->max_tx_rate = evport->info.max_rate;
+#else
+	ivi->tx_rate = evport->info.max_rate;
+#endif
 	mutex_unlock(&esw->state_lock);
 
 	return 0;
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -35,8 +35,11 @@
 
 #include <linux/if_ether.h>
 #include <linux/if_link.h>
+#include <linux/hashtable.h>
 #include <net/devlink.h>
+#ifdef HAVE_IP_TUNNEL_INFO
 #include <net/ip_tunnels.h>
+#endif
 #include <linux/mlx5/device.h>
 
 #define MLX5_MAX_UC_PER_VPORT(dev) \
@@ -63,14 +66,14 @@ struct l2addr_node {
 
 #define for_each_l2hash_node(hn, tmp, hash, i) \
 	for (i = 0; i < MLX5_L2_ADDR_HASH_SIZE; i++) \
-		hlist_for_each_entry_safe(hn, tmp, &hash[i], hlist)
+		compat_hlist_for_each_entry_safe(hn, tmp, &hash[i], hlist)
 
 #define l2addr_hash_find(hash, mac, type) ({                \
 	int ix = MLX5_L2_ADDR_HASH(mac);                    \
 	bool found = false;                                 \
 	type *ptr = NULL;                                   \
 							    \
-	hlist_for_each_entry(ptr, &hash[ix], node.hlist)    \
+	compat_hlist_for_each_entry(ptr, &hash[ix], node.hlist)    \
 		if (ether_addr_equal(ptr->node.addr, mac)) {\
 			found = true;                       \
 			break;                              \
@@ -208,7 +211,9 @@ struct mlx5_esw_offload {
 	struct mlx5_flow_table *ft_offloads;
 	struct mlx5_flow_group *vport_rx_group;
 	struct mlx5_eswitch_rep *vport_reps;
+#ifdef HAVE_NET_TC_ACT_TC_TUNNEL_KEY_H
 	DECLARE_HASHTABLE(encap_tbl, 8);
+#endif
 	u8 inline_mode;
 	u64 num_flows;
 };
@@ -289,17 +294,31 @@ enum {
 #define MLX5_FLOW_CONTEXT_ACTION_VLAN_POP  0x40
 #define MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH 0x80
 
+#ifdef HAVE_NET_TC_ACT_TC_TUNNEL_KEY_H
+#ifndef HAVE_IP_TUNNEL_INFO
+struct mlx5_encap_info {
+	__be32 daddr;
+	__be32 tun_id;
+	__be16 tp_dst;
+};
+#endif
+
 struct mlx5_encap_entry {
 	struct hlist_node encap_hlist;
 	struct list_head flows;
 	u32 encap_id;
 	struct neighbour *n;
+#ifdef HAVE_IP_TUNNEL_INFO
 	struct ip_tunnel_info tun_info;
+#else
+	struct mlx5_encap_info tun_info;
+#endif
 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
 
 	struct net_device *out_dev;
 	int tunnel_type;
 };
+#endif
 
 struct mlx5_esw_flow_attr {
 	struct mlx5_eswitch_rep *in_rep;
@@ -308,7 +327,9 @@ struct mlx5_esw_flow_attr {
 	int	action;
 	u16	vlan;
 	bool	vlan_handled;
+#ifdef HAVE_TCF_TUNNEL_INFO
 	struct mlx5_encap_entry *encap;
+#endif
 };
 
 int mlx5_eswitch_sqs2vport_start(struct mlx5_eswitch *esw,
@@ -317,10 +338,16 @@ int mlx5_eswitch_sqs2vport_start(struct
 void mlx5_eswitch_sqs2vport_stop(struct mlx5_eswitch *esw,
 				 struct mlx5_eswitch_rep *rep);
 
+#ifdef HAVE_DEVLINK_H
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode);
 int mlx5_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode);
+#endif
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_INLINE_MODE_GET_SET
 int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode);
 int mlx5_devlink_eswitch_inline_mode_get(struct devlink *devlink, u8 *mode);
+#endif
+#endif
 int mlx5_eswitch_inline_mode_get(struct mlx5_eswitch *esw, int nvfs, u8 *mode);
 
 int mlx5_eswitch_vport_modify_other_hca_cap_roce(struct mlx5_eswitch *esw,
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -83,11 +83,13 @@ mlx5_eswitch_add_offloaded_rule(struct m
 
 	spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS |
 				      MLX5_MATCH_MISC_PARAMETERS;
+#ifdef HAVE_TCF_TUNNEL_INFO
 	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP)
 		spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
 
 	if (attr->encap)
 		flow_act.encap_id = attr->encap->encap_id;
+#endif
 
 	rule = mlx5_add_flow_rules((struct mlx5_flow_table *)esw->fdb_table.fdb,
 				   spec, &flow_act, dest, i);
@@ -452,9 +454,11 @@ static int esw_create_offloads_fdb_table
 	esw_size = min_t(int, MLX5_CAP_GEN(dev, max_flow_counter) * ESW_OFFLOADS_NUM_GROUPS,
 			 1 << MLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size));
 
+#ifdef HAVE_TCF_TUNNEL_INFO
 	if (MLX5_CAP_ESW_FLOWTABLE_FDB(dev, encap) &&
 	    MLX5_CAP_ESW_FLOWTABLE_FDB(dev, decap))
 		flags |= MLX5_FLOW_TABLE_TUNNEL_EN;
+#endif
 
 	fdb = mlx5_create_auto_grouped_flow_table(root_ns, FDB_FAST_PATH,
 						  esw_size,
@@ -669,6 +673,7 @@ out:
 	return flow_rule;
 }
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 static int esw_offloads_start(struct mlx5_eswitch *esw)
 {
 	int err, err1, num_vfs = esw->dev->priv.sriov.num_vfs;
@@ -696,6 +701,7 @@ static int esw_offloads_start(struct mlx
 	}
 	return err;
 }
+#endif
 
 int esw_offloads_init(struct mlx5_eswitch *esw, int nvports)
 {
@@ -756,6 +762,7 @@ create_fdb_err:
 	return err;
 }
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 static int esw_offloads_stop(struct mlx5_eswitch *esw)
 {
 	int err, err1, num_vfs = esw->dev->priv.sriov.num_vfs;
@@ -776,6 +783,7 @@ static int esw_offloads_stop(struct mlx5
 
 	return err;
 }
+#endif
 
 void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
 {
@@ -794,6 +802,7 @@ void esw_offloads_cleanup(struct mlx5_es
 	esw_destroy_offloads_fdb_table(esw);
 }
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 static int esw_mode_from_devlink(u16 mode, u16 *mlx5_mode)
 {
 	switch (mode) {
@@ -809,7 +818,9 @@ static int esw_mode_from_devlink(u16 mod
 
 	return 0;
 }
+#endif
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 static int esw_mode_to_devlink(u16 mlx5_mode, u16 *mode)
 {
 	switch (mlx5_mode) {
@@ -825,7 +836,9 @@ static int esw_mode_to_devlink(u16 mlx5_
 
 	return 0;
 }
+#endif
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_INLINE_MODE_GET_SET
 static int esw_inline_mode_from_devlink(u8 mode, u8 *mlx5_mode)
 {
 	switch (mode) {
@@ -869,7 +882,9 @@ static int esw_inline_mode_to_devlink(u8
 
 	return 0;
 }
+#endif
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode)
 {
 	struct mlx5_core_dev *dev;
@@ -898,7 +913,9 @@ int mlx5_devlink_eswitch_mode_set(struct
 	else
 		return -EINVAL;
 }
+#endif
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 int mlx5_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode)
 {
 	struct mlx5_core_dev *dev;
@@ -913,7 +930,9 @@ int mlx5_devlink_eswitch_mode_get(struct
 
 	return esw_mode_to_devlink(dev->priv.eswitch->mode, mode);
 }
+#endif
 
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_INLINE_MODE_GET_SET
 int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode)
 {
 	struct mlx5_core_dev *dev = devlink_priv(devlink);
@@ -983,6 +1002,7 @@ int mlx5_devlink_eswitch_inline_mode_get
 
 	return esw_inline_mode_to_devlink(esw->offloads.inline_mode, mode);
 }
+#endif
 
 int mlx5_eswitch_inline_mode_get(struct mlx5_eswitch *esw, int nvfs, u8 *mode)
 {
