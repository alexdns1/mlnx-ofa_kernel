From: Shay Drory <shayd@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/main.c

Change-Id: I9a54f45284336ef4a01d07cfae2b89e22fd0c3e3
---
 .../net/ethernet/mellanox/mlx5/core/main.c    | 210 ++++++++++++++++--
 1 file changed, 196 insertions(+), 14 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -93,6 +93,13 @@ static unsigned int prof_sel = MLX5_DEFA
 module_param_named(prof_sel, prof_sel, uint, 0444);
 MODULE_PARM_DESC(prof_sel, "profile selector. Valid range 0 - 3");
 
+
+#ifdef HAVE_BASECODE_EXTRAS
+static bool probe_vf = 1;
+module_param_named(probe_vf, probe_vf, bool, 0644);
+MODULE_PARM_DESC(probe_vf, "probe VFs or not, 0 = not probe, 1 = probe. Default = 1");
+#endif
+
 MODULE_ALIAS("auxiliary:mlx5_core.eth");
 MODULE_ALIAS("auxiliary:mlx5_core.eth-rep");
 
@@ -706,13 +713,18 @@ set:
 	return err;
 }
 
+#ifdef HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH
 static int max_uc_list_get_devlink_param(struct mlx5_core_dev *dev)
 {
 	struct devlink *devlink = priv_to_devlink(dev);
 	union devlink_param_value val;
 	int err;
 
-	err = devlink_param_driverinit_value_get(devlink,
+#ifdef HAVE_DEVL_PARAM_DRIVERINIT_VALUE_GET
+        err = devl_param_driverinit_value_get(devlink,
+#else
+        err = devlink_param_driverinit_value_get(devlink,
+#endif
 						 DEVLINK_PARAM_GENERIC_ID_MAX_MACS,
 						 &val);
 	if (!err)
@@ -720,14 +732,20 @@ static int max_uc_list_get_devlink_param
 	mlx5_core_dbg(dev, "Failed to get param. err = %d\n", err);
 	return err;
 }
+#endif
 
 bool mlx5_is_roce_on(struct mlx5_core_dev *dev)
 {
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
 	struct devlink *devlink = priv_to_devlink(dev);
 	union devlink_param_value val;
 	int err;
 
+#ifdef HAVE_DEVL_PARAM_DRIVERINIT_VALUE_GET
+	err = devl_param_driverinit_value_get(devlink,
+#else
 	err = devlink_param_driverinit_value_get(devlink,
+#endif
 						 DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,
 						 &val);
 
@@ -736,6 +754,9 @@ bool mlx5_is_roce_on(struct mlx5_core_de
 
 	mlx5_core_dbg(dev, "Failed to get param. err = %d\n", err);
 	return MLX5_CAP_GEN(dev, roce);
+#else
+	return MLX5_CAP_GEN(dev, roce) && dev->roce.enabled;
+#endif
 }
 EXPORT_SYMBOL(mlx5_is_roce_on);
 
@@ -768,7 +789,9 @@ static int handle_hca_cap(struct mlx5_co
 {
 	struct mlx5_profile *prof = &dev->profile;
 	void *set_hca_cap;
+#ifdef HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH
 	int max_uc_list;
+#endif
 	int err;
 
 	err = mlx5_core_get_caps(dev, MLX5_CAP_GENERAL);
@@ -840,18 +863,24 @@ static int handle_hca_cap(struct mlx5_co
 
 	mlx5_vhca_state_cap_handle(dev, set_hca_cap);
 
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 	if (MLX5_CAP_GEN_MAX(dev, num_total_dynamic_vf_msix))
 		MLX5_SET(cmd_hca_cap, set_hca_cap, num_total_dynamic_vf_msix,
 			 MLX5_CAP_GEN_MAX(dev, num_total_dynamic_vf_msix));
+#endif
 
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
 	if (MLX5_CAP_GEN(dev, roce_rw_supported) && MLX5_CAP_GEN_MAX(dev, roce))
 		MLX5_SET(cmd_hca_cap, set_hca_cap, roce,
 			 mlx5_is_roce_on(dev));
+#endif
 
+#ifdef HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH
 	max_uc_list = max_uc_list_get_devlink_param(dev);
 	if (max_uc_list > 0)
 		MLX5_SET(cmd_hca_cap, set_hca_cap, log_max_current_uc_list,
 			 ilog2(max_uc_list));
+#endif
 
 	return set_caps(dev, set_ctx, MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE);
 }
@@ -872,8 +901,12 @@ static int handle_hca_cap(struct mlx5_co
  */
 static bool is_roce_fw_disabled(struct mlx5_core_dev *dev)
 {
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
 	return (MLX5_CAP_GEN(dev, roce_rw_supported) && !mlx5_is_roce_on(dev)) ||
 		(!MLX5_CAP_GEN(dev, roce_rw_supported) && !MLX5_CAP_GEN(dev, roce));
+#else
+	return !MLX5_CAP_GEN(dev, roce);
+#endif
 }
 
 static int handle_hca_cap_roce(struct mlx5_core_dev *dev, void *set_ctx)
@@ -1093,6 +1126,9 @@ static ssize_t mlx5_roce_enable_show_ena
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 	int ret;
 
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
+	return -EOPNOTSUPP;
+#endif
 	mutex_lock(&dev->roce.state_lock);
 	ret = dev->roce.enabled;
 	mutex_unlock(&dev->roce.state_lock);
@@ -1106,11 +1142,15 @@ static ssize_t mlx5_roce_enable_set_enab
 {
 	struct pci_dev *pdev = container_of(device, struct pci_dev, dev);
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
-	struct devlink *devlink = priv_to_devlink(dev);
-	union devlink_param_value value;
+#if !defined(HAVE_DEVLINK_HAS_RELOAD) && !defined(HAVE_DEVLINK_HAS_RELOAD_UP_DOWN)
+	bool change;
+#endif
 	int ret;
 	bool val;
 
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
+	return -EOPNOTSUPP;
+#endif
 	ret = kstrtobool(buf, &val);
 	if (ret)
 		return -EINVAL;
@@ -1118,15 +1158,26 @@ static ssize_t mlx5_roce_enable_set_enab
 	if (val && !MLX5_CAP_GEN(dev, roce))
 		return -EOPNOTSUPP;
 
+	if (mlx5_core_is_mp_slave(dev) || mlx5_lag_is_active(dev))
+		return -EOPNOTSUPP;
+
 	mutex_lock(&dev->roce.state_lock);
+#if !defined(HAVE_DEVLINK_HAS_RELOAD) && !defined(HAVE_DEVLINK_HAS_RELOAD_UP_DOWN)
+	change = dev->roce.enabled != val;
+#endif
 	dev->roce.enabled = val;
-	value.vbool = val;
-	devlink_param_driverinit_value_set(devlink,
-			DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,
-			value);
 	mutex_unlock(&dev->roce.state_lock);
+#if !defined(HAVE_DEVLINK_HAS_RELOAD) && !defined(HAVE_DEVLINK_HAS_RELOAD_UP_DOWN)
+	if (mlx5_sf_dev_allocated(dev))
+		return -EOPNOTSUPP;
 
-	return count;
+	if (!change)
+		return count;
+
+	mlx5_unload_one(dev, false);
+	ret = mlx5_load_one(dev, false);
+#endif
+	return (ret != 0 ? ret : count);
 }
 
 static DEVICE_ATTR(roce_enable, 0644, mlx5_roce_enable_show_enabled,
@@ -1695,10 +1746,14 @@ static void mlx5_unload(struct mlx5_core
 
 int mlx5_init_one(struct mlx5_core_dev *dev)
 {
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	struct devlink *devlink = priv_to_devlink(dev);
+#endif
 	int err = 0;
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_lock(devlink);
+#endif
 	mutex_lock(&dev->intf_state_mutex);
 	dev->state = MLX5_DEVICE_STATE_UP;
 
@@ -1723,7 +1778,11 @@ int mlx5_init_one(struct mlx5_core_dev *
 	mlx5_devm_params_publish(dev);
 	set_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state);
 
+#ifdef HAVE_DEVLINK_REGISTER_GET_1_PARAMS
 	err = mlx5_devlink_register(priv_to_devlink(dev));
+#else
+	err = mlx5_devlink_register(priv_to_devlink(dev), dev->device);
+#endif
 	if (err)
 		goto err_devlink_reg;
 
@@ -1732,7 +1791,9 @@ int mlx5_init_one(struct mlx5_core_dev *
 		goto err_register;
 
 	mutex_unlock(&dev->intf_state_mutex);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_unlock(devlink);
+#endif
 	return 0;
 
 err_register:
@@ -1747,7 +1808,9 @@ function_teardown:
 err_function:
 	dev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;
 	mutex_unlock(&dev->intf_state_mutex);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_unlock(devlink);
+#endif
 	return err;
 }
 
@@ -1807,9 +1870,11 @@ succeed:
 
 void mlx5_uninit_one(struct mlx5_core_dev *dev)
 {
-	struct devlink *devlink = priv_to_devlink(dev);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
+       struct devlink *devlink = priv_to_devlink(dev);
 
-	devl_lock(devlink);
+       devl_lock(devlink);
+#endif
 
 	mlx5_unregister_device(dev);
 	if (!mlx5_core_is_sf(dev) && mlx5_try_fast_unload(dev))
@@ -1832,15 +1897,23 @@ void mlx5_uninit_one(struct mlx5_core_de
 	mlx5_function_teardown(dev, true);
 out:
 	mutex_unlock(&dev->intf_state_mutex);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_unlock(devlink);
+#endif
 }
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 int mlx5_load_one_devl_locked(struct mlx5_core_dev *dev, bool recovery)
+#else
+int mlx5_load_one(struct mlx5_core_dev *dev, bool recovery)
+#endif
 {
 	int err = 0;
 	u64 timeout;
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_assert_locked(priv_to_devlink(dev));
+#endif
 	mutex_lock(&dev->intf_state_mutex);
 	if (test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state)) {
 		mlx5_core_warn(dev, "interface is up, NOP\n");
@@ -1889,6 +1962,7 @@ out:
 	return err;
 }
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 int mlx5_load_one(struct mlx5_core_dev *dev, bool recovery)
 {
 	struct devlink *devlink = priv_to_devlink(dev);
@@ -1899,10 +1973,17 @@ int mlx5_load_one(struct mlx5_core_dev *
 	devl_unlock(devlink);
 	return ret;
 }
+#endif
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 void mlx5_unload_one_devl_locked(struct mlx5_core_dev *dev, bool suspend)
+#else
+void mlx5_unload_one(struct mlx5_core_dev *dev, bool suspend)
+#endif
 {
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	devl_assert_locked(priv_to_devlink(dev));
+#endif
 	mutex_lock(&dev->intf_state_mutex);
 
 	mlx5_detach_device(dev, suspend);
@@ -1920,6 +2001,7 @@ out:
 	mutex_unlock(&dev->intf_state_mutex);
 }
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 void mlx5_unload_one(struct mlx5_core_dev *dev, bool suspend)
 {
 	struct devlink *devlink = priv_to_devlink(dev);
@@ -1928,6 +2010,7 @@ void mlx5_unload_one(struct mlx5_core_de
 	mlx5_unload_one_devl_locked(dev, suspend);
 	devl_unlock(devlink);
 }
+#endif
 
 static const int types[] = {
 	MLX5_CAP_GENERAL,
@@ -1996,9 +2079,13 @@ int mlx5_mdev_init(struct mlx5_core_dev
 	memcpy(&dev->profile, &profile[profile_idx], sizeof(dev->profile));
 	INIT_LIST_HEAD(&priv->ctx_list);
 	spin_lock_init(&priv->ctx_lock);
+#ifdef HAVE_LOCKDEP_UNREGISTER_KEY
 	lockdep_register_key(&dev->lock_key);
+#endif
 	mutex_init(&dev->intf_state_mutex);
+#ifdef HAVE_LOCKDEP_UNREGISTER_KEY
 	lockdep_set_class(&dev->intf_state_mutex, &dev->lock_key);
+#endif
 	mutex_init(&dev->mlx5e_res.uplink_netdev_lock);
 
 	mutex_init(&priv->bfregs.reg_head.lock);
@@ -2042,7 +2129,11 @@ int mlx5_mdev_init(struct mlx5_core_dev
 	 * Those values are supplied to FW as part of the init HCA command to
 	 * be used by both driver and FW when it's applicable.
 	 */
+#ifdef HAVE_IDA_ALLOC_RANGE
 	dev->priv.sw_vhca_id = ida_alloc_range(&sw_vhca_ida, 1,
+#else
+	dev->priv.sw_vhca_id = ida_simple_get(&sw_vhca_ida, 1,
+#endif
 					       MAX_SW_VHCA_ID,
 					       GFP_KERNEL);
 	if (dev->priv.sw_vhca_id < 0)
@@ -2066,7 +2157,9 @@ err_timeout_init:
 	mutex_destroy(&priv->bfregs.wc_head.lock);
 	mutex_destroy(&priv->bfregs.reg_head.lock);
 	mutex_destroy(&dev->intf_state_mutex);
+#ifdef HAVE_LOCKDEP_UNREGISTER_KEY
 	lockdep_unregister_key(&dev->lock_key);
+#endif
 	return err;
 }
 
@@ -2075,7 +2168,11 @@ void mlx5_mdev_uninit(struct mlx5_core_d
 	struct mlx5_priv *priv = &dev->priv;
 
 	if (priv->sw_vhca_id > 0)
+#ifdef HAVE_IDA_FREE
 		ida_free(&sw_vhca_ida, dev->priv.sw_vhca_id);
+#else
+		ida_simple_remove(&sw_vhca_ida, dev->priv.sw_vhca_id);
+#endif
 
 	mlx5_hca_caps_free(dev);
 	mlx5_adev_cleanup(dev);
@@ -2089,13 +2186,18 @@ void mlx5_mdev_uninit(struct mlx5_core_d
 	mutex_destroy(&priv->bfregs.reg_head.lock);
 	mutex_destroy(&dev->mlx5e_res.uplink_netdev_lock);
 	mutex_destroy(&dev->intf_state_mutex);
+#ifdef HAVE_LOCKDEP_UNREGISTER_KEY
 	lockdep_unregister_key(&dev->lock_key);
+#endif
 }
 
 static int probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
-	struct mlx5_core_dev *dev;
+	struct mlx5_core_dev *dev = NULL;
 	struct devlink *devlink;
+#ifdef HAVE_BASECODE_EXTRAS
+	struct mlx5_priv *priv;
+#endif
 	int err;
 
 	devlink = mlx5_devlink_alloc(&pdev->dev);
@@ -2105,16 +2207,29 @@ static int probe_one(struct pci_dev *pde
 	}
 
 	err = device_create_file(&pdev->dev, mlx5_roce_enable_dev_attrs);
-	if (err) 
+	if (err)
 		goto remove_roce_file;
 
 	dev = devlink_priv(devlink);
+#ifdef HAVE_BASECODE_EXTRAS
+	priv = &dev->priv;
+#endif
 	dev->device = &pdev->dev;
 	dev->pdev = pdev;
+#ifdef HAVE_BASECODE_EXTRAS
+	priv->sriov.probe_vf = probe_vf;
+#endif
 
 	dev->coredev_type = id->driver_data & MLX5_PCI_DEV_IS_VF ?
 			 MLX5_COREDEV_VF : MLX5_COREDEV_PF;
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !probe_vf) {
+		dev_info(&pdev->dev, "Avoid probing VFs\n");
+		return 0;
+	}
+#endif
+
 	dev->priv.adev_idx = mlx5_adev_idx_alloc();
 	if (dev->priv.adev_idx < 0) {
 		err = dev->priv.adev_idx;
@@ -2151,7 +2266,13 @@ static int probe_one(struct pci_dev *pde
 		dev_err(&pdev->dev, "mlx5_crdump_enable failed with error code %d\n", err);
 
 	pci_save_state(pdev);
+#ifdef HAVE_DEVLINK_REGISTER_GET_1_PARAMS
 	devlink_register(devlink);
+#endif
+#if defined(HAVE_DEVLINK_RELOAD_ENABLE) && !defined(HAVE_DEVLINK_SET_FEATURES)
+       if (!mlx5_core_is_mp_slave(dev))
+	       devlink_reload_enable(devlink);
+#endif
 	return 0;
 
 err_init_one:
@@ -2172,8 +2293,18 @@ remove_roce_file:
 
 static void remove_one(struct pci_dev *pdev)
 {
-	struct mlx5_core_dev *dev  = pci_get_drvdata(pdev);
-	struct devlink *devlink = priv_to_devlink(dev);
+	struct mlx5_core_dev *dev;
+	struct devlink *devlink;
+	struct mlx5_priv *priv;
+
+	dev  = pci_get_drvdata(pdev);
+	devlink = priv_to_devlink(dev);
+	priv = &dev->priv;
+
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !priv->sriov.probe_vf)
+		goto out;
+#endif
 
 	set_bit(MLX5_BREAK_FW_WAIT, &dev->intf_state);
 	/* mlx5_drain_fw_reset() is using devlink APIs. Hence, we must drain
@@ -2181,7 +2312,12 @@ static void remove_one(struct pci_dev *p
 	 */
 	mlx5_drain_fw_reset(dev);
 
+#if defined(HAVE_DEVLINK_RELOAD_DISABLE) && !defined(HAVE_DEVLINK_SET_FEATURES)
+	devlink_reload_disable(devlink);
+#endif
+#ifdef HAVE_DEVLINK_REGISTER_GET_1_PARAMS
 	devlink_unregister(devlink);
+#endif
 	mlx5_sriov_disable(pdev);
 	mlx5_crdump_disable(dev);
 	mlx5_drain_health_wq(dev);
@@ -2190,6 +2326,9 @@ static void remove_one(struct pci_dev *p
 	mlx5_pci_close(dev);
 	mlx5_mdev_uninit(dev);
 	mlx5_adev_idx_free(dev->priv.adev_idx);
+#ifdef HAVE_BASECODE_EXTRAS
+out:
+#endif
 	device_remove_file(&pdev->dev, mlx5_roce_enable_dev_attrs);
 	mlx5_devlink_free(devlink);
 }
@@ -2218,6 +2357,10 @@ static int suspend(struct device *device
 
 	dev_info(&pdev->dev, "suspend was called\n");
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !dev->priv.sriov.probe_vf)
+		return 0;
+#endif
 	mlx5_unload_one(dev, true);
 
 	err = pci_save_state(pdev);
@@ -2250,6 +2393,11 @@ static int resume(struct device *device)
 
 	dev_info(&pdev->dev, "resume was called\n");
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !dev->priv.sriov.probe_vf)
+		return 0;
+#endif
+
 	err = pci_set_power_state(pdev, PCI_D0);
 	if (err) {
 		dev_warn(&pdev->dev, "pci_set_power_state failed with error code: %d\n", err);
@@ -2292,6 +2440,11 @@ static pci_ers_result_t mlx5_pci_err_det
 
 	mlx5_pci_trace(dev, "Enter, pci channel state = %d\n", state);
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !dev->priv.sriov.probe_vf)
+		return PCI_ERS_RESULT_CAN_RECOVER;
+#endif
+
 	mlx5_enter_error_state(dev, false);
 	mlx5_error_sw_reset(dev);
 	mlx5_unload_one(dev, true);
@@ -2344,6 +2497,11 @@ static pci_ers_result_t mlx5_pci_slot_re
 	mlx5_core_info(dev, "%s Device state = %d pci_status: %d. Enter\n",
 		       __func__, dev->state, dev->pci_status);
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !dev->priv.sriov.probe_vf)
+		return PCI_ERS_RESULT_NEED_RESET;
+#endif
+
 	err = mlx5_pci_enable_device(dev);
 	if (err) {
 		mlx5_core_err(dev, "%s: mlx5_pci_enable_device failed with error code: %d\n",
@@ -2376,12 +2534,19 @@ static void mlx5_pci_resume(struct pci_d
 
 	mlx5_pci_trace(dev, "Enter, loading driver..\n");
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !dev->priv.sriov.probe_vf)
+		return;
+#endif
+
 	dev->priv.sw_reset_lag = dev->priv.lag_enabled;
 	err = mlx5_load_one(dev, false);
 
+#ifdef HAVE_DEVLINK_HEALTH_REPORTER_STATE_UPDATE
 	if (!err)
 		devlink_health_reporter_state_update(dev->priv.health.fw_fatal_reporter,
 						     DEVLINK_HEALTH_REPORTER_STATE_HEALTHY);
+#endif
 
 	mlx5_pci_trace(dev, "Done, err = %d, device %s\n", err,
 		       !err ? "recovered" : "Failed");
@@ -2401,6 +2566,11 @@ static void shutdown(struct pci_dev *pde
 
 	mlx5_core_info(dev, "Shutdown was called\n");
 
+#ifdef HAVE_BASECODE_EXTRAS
+	if (pdev->is_virtfn && !dev->priv.sriov.probe_vf)
+		return;
+#endif
+
 	set_bit(MLX5_BREAK_FW_WAIT, &dev->intf_state);
 	err = mlx5_try_fast_unload(dev);
 	if (err) {
@@ -2462,7 +2632,11 @@ MODULE_DEVICE_TABLE(pci, mlx5_core_pci_t
 void mlx5_disable_device(struct mlx5_core_dev *dev)
 {
 	mlx5_error_sw_reset(dev);
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	mlx5_unload_one_devl_locked(dev, false);
+#else
+	mlx5_unload_one(dev, false);
+#endif
 }
 
 int mlx5_recover_device(struct mlx5_core_dev *dev)
@@ -2473,7 +2647,11 @@ int mlx5_recover_device(struct mlx5_core
 			return -EIO;
 	}
 
+#ifdef HAVE_DEVL_TRAP_GROUPS_REGISTER
 	return mlx5_load_one_devl_locked(dev, true);
+#else
+	return mlx5_load_one(dev, true);
+#endif
 }
 
 static struct pci_driver mlx5_core_driver = {
@@ -2491,10 +2669,13 @@ static struct pci_driver mlx5_core_drive
 	.shutdown	= shutdown,
 	.err_handler	= &mlx5_err_handler,
 	.sriov_configure   = mlx5_core_sriov_configure,
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 	.sriov_get_vf_total_msix = mlx5_sriov_get_vf_total_msix,
 	.sriov_set_msix_vec_count = mlx5_core_sriov_set_msix_vec_count,
+#endif
 };
 
+#ifdef HAVE_PCI_IOV_GET_PF_DRVDATA
 /**
  * mlx5_vf_get_core_dev - Get the mlx5 core device from a given VF PCI device if
  *                     mlx5_core is its driver.
@@ -2536,6 +2717,7 @@ void mlx5_vf_put_core_dev(struct mlx5_co
 	mutex_unlock(&mdev->intf_state_mutex);
 }
 EXPORT_SYMBOL(mlx5_vf_put_core_dev);
+#endif
 
 static void mlx5_core_verify_params(void)
 {
