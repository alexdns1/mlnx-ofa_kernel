From: Valentine Fatiev <valentinef@mellanox.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/en_tc.c

Change-Id: I06429bc5ebd1267785a62fe46b3d84cd7b194c37
---
 .../net/ethernet/mellanox/mlx5/core/en_tc.c   | 327 +++++++++++++++++-
 1 file changed, 319 insertions(+), 8 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -963,8 +963,10 @@ mlx5e_tc_add_nic_flow(struct mlx5e_priv
 							    &ft_attr);
 		if (IS_ERR(priv->fs.tc.t)) {
 			mutex_unlock(&priv->fs.tc.t_lock);
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "Failed to create tc offload table\n");
+#endif
 			netdev_err(priv->netdev,
 				   "Failed to create tc offload table\n");
 			return PTR_ERR(priv->fs.tc.t);
@@ -1511,14 +1513,17 @@ void mlx5e_tc_update_neigh_used_value(st
 	struct neighbour *n;
 	u64 lastuse;
 
-	if (m_neigh->family == AF_INET)
+	if (m_neigh->family == AF_INET) {
 		tbl = &arp_tbl;
-#if IS_ENABLED(CONFIG_IPV6)
-	else if (m_neigh->family == AF_INET6)
+#if defined(HAVE_IPV6_STUBS_H) && IS_ENABLED(CONFIG_IPV6)
+	} else if (m_neigh->family == AF_INET6) {
+		if (!ipv6_stub || !ipv6_stub->nd_tbl)
+			return;
 		tbl = ipv6_stub->nd_tbl;
 #endif
-	else
+	} else {
 		return;
+	}
 
 	/* mlx5e_get_next_valid_encap() releases previous encap before returning
 	 * next one.
@@ -1557,7 +1562,9 @@ void mlx5e_tc_update_neigh_used_value(st
 		}
 	}
 
+#ifndef MLX_DISABLE_TRACEPOINTS
 	trace_mlx5e_tc_update_neigh_used_value(nhe, neigh_used);
+#endif
 
 	if (neigh_used) {
 		nhe->reported_lastuse = jiffies;
@@ -1718,8 +1725,10 @@ enc_opts_is_dont_care_or_full_match(stru
 
 			if (opt->opt_class != U16_MAX ||
 			    opt->type != U8_MAX) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 				NL_SET_ERR_MSG(extack,
 					       "Partial match of tunnel options in chain > 0 isn't supported");
+#endif
 				netdev_warn(priv->netdev,
 					    "Partial match of tunnel options in chain > 0 isn't supported");
 				return -EOPNOTSUPP;
@@ -1750,7 +1759,11 @@ static int mlx5e_get_flow_tunnel_id(stru
 				    struct net_device *filter_dev)
 {
 	struct flow_rule *rule = flow_cls_offload_flow_rule(f);
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#else
+	struct netlink_ext_ack *extack = NULL;
+#endif
 	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
 	struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts;
 	struct flow_match_enc_opts enc_opts_match;
@@ -1872,7 +1885,9 @@ static int parse_tunnel_attr(struct mlx5
 			     bool *match_inner)
 {
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#endif
 	bool needs_mapping, sets_mapping;
 	int err;
 
@@ -1885,8 +1900,10 @@ static int parse_tunnel_attr(struct mlx5
 
 	if ((needs_mapping || sets_mapping) &&
 	    !mlx5_eswitch_reg_c1_loopback_enabled(esw)) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG(extack,
 			       "Chains on tunnel devices isn't supported without register loopback support");
+#endif
 		netdev_warn(priv->netdev,
 			    "Chains on tunnel devices isn't supported without register loopback support");
 		return -EOPNOTSUPP;
@@ -1896,8 +1913,10 @@ static int parse_tunnel_attr(struct mlx5
 		err = mlx5e_tc_tun_parse(filter_dev, priv, spec, f,
 					 match_level);
 		if (err) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "Failed to parse tunnel attributes");
+#endif
 			netdev_warn(priv->netdev,
 				    "Failed to parse tunnel attributes");
 			return err;
@@ -1956,9 +1975,16 @@ static int mlx5e_flower_parse_meta(struc
 				   struct flow_cls_offload *f)
 {
 	struct flow_rule *rule = flow_cls_offload_flow_rule(f);
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#else
+	struct netlink_ext_ack *extack;
+#endif
 	struct net_device *ingress_dev;
 	struct flow_match_meta match;
+#ifndef HAVE_TC_CLS_OFFLOAD_EXTACK
+	extack = NULL;
+#endif
 
 	if (!flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_META))
 		return 0;
@@ -1994,7 +2020,11 @@ static int __parse_cls_flower(struct mlx
 			      u8 *inner_match_level, u8 *outer_match_level,
 			      bool *is_tunnel_flow)
 {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#else
+	struct netlink_ext_ack *extack;
+#endif
 	void *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
 				       outer_headers);
 	void *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
@@ -2009,6 +2039,9 @@ static int __parse_cls_flower(struct mlx
 	u8 ip_proto = 0;
 	u8 *match_level;
 	int err;
+#ifndef HAVE_TC_CLS_OFFLOAD_EXTACK
+	extack = NULL;
+#endif
 
 	match_level = outer_match_level;
 
@@ -2032,13 +2065,27 @@ static int __parse_cls_flower(struct mlx
 	      BIT(FLOW_DISSECTOR_KEY_CT) |
 	      BIT(FLOW_DISSECTOR_KEY_ENC_IP) |
 	      BIT(FLOW_DISSECTOR_KEY_ENC_OPTS))) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack, "Unsupported key");
+#endif
 		netdev_warn(priv->netdev, "Unsupported key used: 0x%x\n",
 			    dissector->used_keys);
 		return -EOPNOTSUPP;
 	}
 
-	if (mlx5e_get_tc_tun(filter_dev)) {
+#if !defined(HAVE_TC_INDR_API) && !defined(CONFIG_COMPAT_KERNEL_4_14)
+	/* for old kernels we dont have real filter_dev,
+	 * and mlx5e_get_tc_tun always return vxlan
+	 */
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) ||
+	    flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) ||
+	    flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID) ||
+	    flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_PORTS) ||
+	    flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_OPTS))
+#else
+	if (mlx5e_get_tc_tun(filter_dev))
+#endif
+	{
 		bool match_inner = false;
 
 		err = parse_tunnel_attr(priv, flow, spec, f, filter_dev,
@@ -2327,8 +2374,10 @@ static int __parse_cls_flower(struct mlx
 				 udp_dport, ntohs(match.key->dst));
 			break;
 		default:
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "Only UDP and TCP transports are supported for L4 matching");
+#endif
 			netdev_err(priv->netdev,
 				   "Only UDP and TCP transport are supported\n");
 			return -EINVAL;
@@ -2361,7 +2410,9 @@ static int parse_cls_flower(struct mlx5e
 			    struct net_device *filter_dev)
 {
 	u8 inner_match_level, outer_match_level, non_tunnel_match_level;
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#endif
 	struct mlx5_core_dev *dev = priv->mdev;
 	struct mlx5_eswitch *esw = dev->priv.eswitch;
 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
@@ -2385,8 +2436,10 @@ static int parse_cls_flower(struct mlx5e
 		if (rep->vport != MLX5_VPORT_UPLINK &&
 		    (esw->offloads.inline_mode != MLX5_INLINE_MODE_NONE &&
 		    esw->offloads.inline_mode < non_tunnel_match_level)) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "Flow is not offloaded due to min inline setting");
+#endif
 			netdev_warn(priv->netdev,
 				    "Flow is not offloaded due to min inline setting, required %d actual %d\n",
 				    non_tunnel_match_level, esw->offloads.inline_mode);
@@ -2584,8 +2637,10 @@ static int offload_pedit_fields(struct m
 			continue;
 
 		if (s_mask && a_mask) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "can't set and add to the same HW field");
+#endif
 			printk(KERN_WARNING "mlx5: can't set and add to the same HW field (%x)\n", f->field);
 			return -EOPNOTSUPP;
 		}
@@ -2630,8 +2685,10 @@ static int offload_pedit_fields(struct m
 		next_z = find_next_zero_bit(&mask, f->field_bsize, first);
 		last  = find_last_bit(&mask, f->field_bsize);
 		if (first < next_z && next_z < last) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "rewrite of few sub-fields isn't supported");
+#endif
 			printk(KERN_WARNING "mlx5: rewrite of few sub-fields (mask %lx) isn't offloaded\n",
 			       mask);
 			return -EOPNOTSUPP;
@@ -2639,8 +2696,10 @@ static int offload_pedit_fields(struct m
 
 		err = alloc_mod_hdr_actions(priv->mdev, namespace, mod_acts);
 		if (err) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "too many pedit actions, can't offload");
+#endif
 			mlx5_core_warn(priv->mdev,
 				       "mlx5: parsed %d pedit actions, can't do more\n",
 				       mod_acts->num_actions);
@@ -2788,8 +2847,10 @@ static int alloc_tc_pedit_action(struct
 	for (cmd = 0; cmd < __PEDIT_CMD_MAX; cmd++) {
 		cmd_masks = &hdrs[cmd].masks;
 		if (memcmp(cmd_masks, &zero_masks, sizeof(zero_masks))) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "attempt to offload an unsupported field");
+#endif
 			netdev_warn(priv->netdev, "attempt to offload an unsupported field (cmd %d)\n", cmd);
 			print_hex_dump(KERN_WARNING, "mask: ", DUMP_PREFIX_ADDRESS,
 				       16, 1, cmd_masks, sizeof(zero_masks), true);
@@ -2815,16 +2876,20 @@ static bool csum_offload_supported(struc
 
 	/*  The HW recalcs checksums only if re-writing headers */
 	if (!(action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack,
 				   "TC csum action is only offloaded with pedit");
+#endif
 		netdev_warn(priv->netdev,
 			    "TC csum action is only offloaded with pedit\n");
 		return false;
 	}
 
 	if (update_flags & ~prot_flags) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack,
 				   "can't offload TC csum action for some header/s");
+#endif
 		netdev_warn(priv->netdev,
 			    "can't offload TC csum action for some header/s - flags %#x\n",
 			    update_flags);
@@ -2951,8 +3016,10 @@ static bool modify_header_match_supporte
 	 */
 	if (!ct_clear && modify_tuple &&
 	    mlx5_tc_ct_add_no_trk_match(priv, spec)) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack,
 				   "can't offload tuple modify header with ct matches");
+#endif
 		netdev_info(priv->netdev,
 			    "can't offload tuple modify header with ct matches");
 		return false;
@@ -2961,8 +3028,10 @@ static bool modify_header_match_supporte
 	ip_proto = MLX5_GET(fte_match_set_lyr_2_4, headers_v, ip_protocol);
 	if (modify_ip_header && ip_proto != IPPROTO_TCP &&
 	    ip_proto != IPPROTO_UDP && ip_proto != IPPROTO_ICMP) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack,
 				   "can't offload re-write of non TCP/UDP");
+#endif
 		netdev_info(priv->netdev, "can't offload re-write of ip proto %d\n",
 			    ip_proto);
 		return false;
@@ -3159,8 +3228,10 @@ static int parse_tc_nic_actions(struct m
 				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 			} else {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 				NL_SET_ERR_MSG_MOD(extack,
 						   "device is not on same HW, can't offload");
+#endif
 				netdev_warn(priv->netdev, "device %s not on same HW, can't offload\n",
 					    peer_dev->name);
 				return -EINVAL;
@@ -3283,7 +3354,9 @@ static bool is_duplicated_encap_entry(st
 	for (i = 0; i < out_index; i++) {
 		if (flow->encaps[i].e != e)
 			continue;
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack, "can't duplicate encap action");
+#endif
 		netdev_err(priv->netdev, "can't duplicate encap action\n");
 		return true;
 	}
@@ -3360,6 +3433,7 @@ static int mlx5e_attach_encap(struct mlx
 	}
 	e->tun_info = tun_info;
 	err = mlx5e_tc_tun_init_encap_attr(mirred_dev, priv, e, extack);
+
 	if (err)
 		goto out_err_init;
 
@@ -3521,8 +3595,12 @@ static int add_vlan_pop_action(struct ml
 	};
 	int nest_level, err = 0;
 
+#ifdef HAVE_NET_DEVICE_HAS_LOWER_LEVEL
 	nest_level = attr->parse_attr->filter_dev->lower_level -
 						priv->netdev->lower_level;
+#else
+	nest_level = vlan_get_encap_level(attr->parse_attr->filter_dev);
+#endif
 	while (nest_level--) {
 		err = parse_tc_vlan_action(priv, &vlan_act, attr, action);
 		if (err)
@@ -3574,8 +3652,10 @@ static bool is_duplicated_output_device(
 
 	for (i = 0; i < if_count; i++) {
 		if (ifindexes[i] == out_dev->ifindex) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG_MOD(extack,
 					   "can't duplicate output to same device");
+#endif
 			netdev_err(dev, "can't duplicate output to same device: %s\n",
 				   out_dev->name);
 			return true;
@@ -3651,8 +3731,10 @@ static int parse_tc_fdb_actions(struct m
 			}
 
 			if (attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 				NL_SET_ERR_MSG_MOD(extack,
 						   "can't support more output ports, can't offload forwarding");
+#endif
 				pr_err("can't support more than %d output ports, can't offload forwarding\n",
 				       attr->out_count);
 				return -EOPNOTSUPP;
@@ -3716,8 +3798,10 @@ static int parse_tc_fdb_actions(struct m
 				rep_priv = mlx5e_rep_to_rep_priv(attr->in_rep);
 				if (mlx5e_eswitch_uplink_rep(rep_priv->netdev) &&
 				    mlx5e_eswitch_uplink_rep(out_dev)) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 					NL_SET_ERR_MSG_MOD(extack,
 							   "devices are both uplink, can't offload forwarding");
+#endif
 					pr_err("devices %s %s are both uplink, can't offload forwarding\n",
 					       priv->netdev->name, out_dev->name);
 					return -EOPNOTSUPP;
@@ -3742,8 +3826,10 @@ static int parse_tc_fdb_actions(struct m
 				 */
 				return -EINVAL;
 			} else {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 				NL_SET_ERR_MSG_MOD(extack,
 						   "devices are not on same switch HW, can't offload forwarding");
+#endif
 				pr_err_once("devices %s %s not on same switch HW, can't offload forwarding\n",
 					    priv->netdev->name, out_dev->name);
 				pr_debug("devices %s %s not on same switch HW, can't offload forwarding\n",
@@ -3812,6 +3898,7 @@ static int parse_tc_fdb_actions(struct m
 			attr->dest_chain = dest_chain;
 			break;
 			}
+#ifdef HAVE_FLOW_ACTION_CT
 		case FLOW_ACTION_CT:
 			err = mlx5_tc_ct_parse_action(priv, attr, act, extack);
 			if (err)
@@ -3819,6 +3906,7 @@ static int parse_tc_fdb_actions(struct m
 
 			flow_flag_set(flow, CT);
 			break;
+#endif
 		default:
 			NL_SET_ERR_MSG_MOD(extack, "The offload action is not supported");
 			return -EOPNOTSUPP;
@@ -3870,8 +3958,10 @@ static int parse_tc_fdb_actions(struct m
 			 * device.
 			 */
 
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 			NL_SET_ERR_MSG(extack,
 				       "Decap with goto isn't supported");
+#endif
 			netdev_warn(priv->netdev,
 				    "Decap with goto isn't supported");
 			return -EOPNOTSUPP;
@@ -3891,8 +3981,10 @@ static int parse_tc_fdb_actions(struct m
 	}
 
 	if (attr->split_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack,
 				   "current firmware doesn't support split rule for port mirroring");
+#endif
 		netdev_warn_once(priv->netdev, "current firmware doesn't support split rule for port mirroring\n");
 		return -EOPNOTSUPP;
 	}
@@ -3926,14 +4018,46 @@ static const struct rhashtable_params tc
 	.automatic_shrinking = true,
 };
 
+#ifdef CONFIG_COMPAT_CLS_FLOWER_MOD
+static void get_new_flags(struct mlx5e_priv *priv, unsigned long *flags)
+{
+	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+
+	if (mlx5e_eswitch_rep(priv->netdev) &&
+	    MLX5_VPORT_MANAGER(priv->mdev) && esw->mode == MLX5_ESWITCH_OFFLOADS)
+		*flags |= MLX5_TC_FLAG(ESW_OFFLOAD);
+}
+#elif !defined(HAVE_TC_BLOCK_OFFLOAD) && !defined(HAVE_FLOW_BLOCK_OFFLOAD)
+static void get_new_flags(struct mlx5e_priv *priv, unsigned long *flags)
+{
+	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+
+	if (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)
+		*flags |= MLX5_TC_FLAG(ESW_OFFLOAD);
+}
+#endif
+
 static struct rhashtable *get_tc_ht(struct mlx5e_priv *priv,
 				    unsigned long flags)
 {
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 	struct mlx5e_rep_priv *uplink_rpriv;
 
+#ifdef CONFIG_COMPAT_CLS_FLOWER_MOD
+	if (mlx5e_eswitch_rep(priv->netdev) &&
+	    MLX5_VPORT_MANAGER(priv->mdev) && esw->mode == MLX5_ESWITCH_OFFLOADS) {
+#elif !defined(HAVE_TC_BLOCK_OFFLOAD) && !defined(HAVE_FLOW_BLOCK_OFFLOAD)
+	if ((flags & MLX5_TC_FLAG(ESW_OFFLOAD)) ||
+	    (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)) {
+#else
 	if (flags & MLX5_TC_FLAG(ESW_OFFLOAD)) {
+#endif
 		uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
+#if !defined(CONFIG_COMPAT_CLS_FLOWER_MOD) && \
+    !defined(HAVE_TC_BLOCK_OFFLOAD) && !defined(HAVE_FLOW_BLOCK_OFFLOAD)
+		if (!uplink_rpriv->uplink_priv.tc_ht.tbl)
+			return &priv->fs.tc.ht;
+#endif
 		return &uplink_rpriv->uplink_priv.tc_ht;
 	} else /* NIC offload */
 		return &priv->fs.tc.ht;
@@ -3942,22 +4066,32 @@ static struct rhashtable *get_tc_ht(stru
 static bool is_peer_flow_needed(struct mlx5e_tc_flow *flow)
 {
 	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
+#ifdef HAVE_QDISC_SUPPORTS_BLOCK_SHARING
 	bool is_rep_ingress = attr->in_rep->vport != MLX5_VPORT_UPLINK &&
 		flow_flag_test(flow, INGRESS);
 	bool act_is_encap = !!(attr->action &
 			       MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT);
+#endif
 	bool esw_paired = mlx5_devcom_is_paired(attr->in_mdev->priv.devcom,
 						MLX5_DEVCOM_ESW_OFFLOADS);
 
 	if (!esw_paired)
 		return false;
 
+#ifdef HAVE_QDISC_SUPPORTS_BLOCK_SHARING
 	if ((mlx5_lag_is_sriov(attr->in_mdev) ||
 	     mlx5_lag_is_multipath(attr->in_mdev)) &&
-	    (is_rep_ingress || act_is_encap))
+	    (is_rep_ingress || act_is_encap
+#ifdef HAVE_TC_SETUP_CB_EGDEV_REGISTER
+	     || (flow->flags & MLX5_TC_FLAG(EGRESS))
+#endif
+	    ))
 		return true;
 
 	return false;
+#else
+	return (mlx5_lag_is_sriov(attr->in_mdev) ||  mlx5_lag_is_multipath(attr->in_mdev));
+#endif
 }
 
 static int
@@ -4008,8 +4142,16 @@ mlx5e_flow_esw_attr_init(struct mlx5_esw
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 
 	esw_attr->parse_attr = parse_attr;
+#ifdef CONFIG_COMPAT_PRIO_CHAIN_SUPPORT
 	esw_attr->chain = f->common.chain_index;
+#ifdef CONFIG_COMPAT_TC_PRIO_IS_MAJOR
 	esw_attr->prio = f->common.prio;
+#else
+	esw_attr->prio = TC_H_MAJ(f->common.prio) >> 16;
+#endif
+#else
+	esw_attr->prio = 1;
+#endif
 
 	esw_attr->in_rep = in_rep;
 	esw_attr->in_mdev = in_mdev;
@@ -4029,12 +4171,24 @@ __mlx5e_add_fdb_flow(struct mlx5e_priv *
 		     struct mlx5_eswitch_rep *in_rep,
 		     struct mlx5_core_dev *in_mdev)
 {
-	struct flow_rule *rule = flow_cls_offload_flow_rule(f);
+	struct flow_rule *rule;
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#else
+	struct netlink_ext_ack *extack = NULL;
+#endif
 	struct mlx5e_tc_flow_parse_attr *parse_attr;
 	struct mlx5e_tc_flow *flow;
 	int attr_size, err;
 
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+	rule = alloc_flow_rule(&f);
+	if (IS_ERR(rule))
+		return ERR_PTR(PTR_ERR(rule));
+#else
+	rule = flow_cls_offload_flow_rule(f);
+#endif
+
 	flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_ESWITCH);
 	attr_size  = sizeof(struct mlx5_esw_flow_attr);
 	err = mlx5e_alloc_flow(priv, attr_size, f, flow_flags,
@@ -4071,11 +4225,18 @@ __mlx5e_add_fdb_flow(struct mlx5e_priv *
 		add_unready_flow(flow);
 	}
 
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+	free_flow_rule(rule);
+#endif
+
 	return flow;
 
 err_free:
 	mlx5e_flow_put(priv, flow);
 out:
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+        free_flow_rule(rule);
+#endif
 	return ERR_PTR(err);
 }
 
@@ -4170,15 +4331,29 @@ mlx5e_add_nic_flow(struct mlx5e_priv *pr
 		   struct net_device *filter_dev,
 		   struct mlx5e_tc_flow **__flow)
 {
-	struct flow_rule *rule = flow_cls_offload_flow_rule(f);
+	struct flow_rule *rule;
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#else
+	struct netlink_ext_ack *extack = NULL;
+#endif
 	struct mlx5e_tc_flow_parse_attr *parse_attr;
 	struct mlx5e_tc_flow *flow;
 	int attr_size, err;
 
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+	rule = alloc_flow_rule(&f);
+	if (IS_ERR(rule))
+		return PTR_ERR(rule);
+#else
+	rule = flow_cls_offload_flow_rule(f);
+#endif
+
+#if defined(HAVE_TC_CLS_OFFLOAD_EXTACK) && defined(CONFIG_COMPAT_PRIO_CHAIN_SUPPORT)
 	/* multi-chain not supported for NIC rules */
 	if (!tc_cls_can_offload_and_chain0(priv->netdev, &f->common))
 		return -EOPNOTSUPP;
+#endif
 
 	flow_flags |= BIT(MLX5E_TC_FLOW_FLAG_NIC);
 	attr_size  = sizeof(struct mlx5_nic_flow_attr);
@@ -4203,6 +4378,9 @@ mlx5e_add_nic_flow(struct mlx5e_priv *pr
 
 	flow_flag_set(flow, OFFLOADED);
 	kvfree(parse_attr);
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+        free_flow_rule(rule);
+#endif
 	*__flow = flow;
 
 	return 0;
@@ -4211,6 +4389,9 @@ err_free:
 	mlx5e_flow_put(priv, flow);
 	kvfree(parse_attr);
 out:
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+        free_flow_rule(rule);
+#endif
 	return err;
 }
 
@@ -4227,8 +4408,10 @@ mlx5e_tc_add_flow(struct mlx5e_priv *pri
 
 	get_flags(flags, &flow_flags);
 
+#if defined(HAVE_TC_CLS_OFFLOAD_EXTACK) && defined(HAVE_TC_CLS_FLOWER_OFFLOAD_COMMON)
 	if (!tc_can_offload_extack(priv->netdev, f->common.extack))
 		return -EOPNOTSUPP;
+#endif
 
 	if (esw && esw->mode == MLX5_ESWITCH_OFFLOADS)
 		err = mlx5e_add_fdb_flow(priv, f, flow_flags,
@@ -4268,12 +4451,19 @@ int mlx5e_configure_flower(struct net_de
 			   struct flow_cls_offload *f, unsigned long flags)
 {
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 	struct netlink_ext_ack *extack = f->common.extack;
+#endif
 	struct rhashtable *tc_ht = get_tc_ht(priv, flags);
 	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 	struct mlx5e_tc_flow *flow;
 	int err = 0;
 
+#if defined(CONFIG_COMPAT_CLS_FLOWER_MOD) || \
+    (!defined(HAVE_TC_BLOCK_OFFLOAD) && !defined(HAVE_FLOW_BLOCK_OFFLOAD))
+	get_new_flags(priv, &flags);
+#endif
+
 	if (get_esw_tc_refcnt(esw))
 		return -EOPNOTSUPP;
 
@@ -4286,8 +4476,15 @@ int mlx5e_configure_flower(struct net_de
 		if (is_flow_rule_duplicate_allowed(dev, rpriv) && flow->orig_dev != dev)
 			goto out_rcu;
 
+#if !defined(HAVE_TC_INDR_API)
+		if(flow->orig_dev != dev)
+			goto out;
+#endif
+
+#ifdef HAVE_TC_CLS_OFFLOAD_EXTACK
 		NL_SET_ERR_MSG_MOD(extack,
 				   "flow cookie already exists, ignoring");
+#endif
 		netdev_warn_once(priv->netdev,
 				 "flow cookie %lx already exists, ignoring\n",
 				 f->cookie);
@@ -4296,7 +4493,9 @@ int mlx5e_configure_flower(struct net_de
 	}
 	rcu_read_unlock();
 
+#ifndef MLX_DISABLE_TRACEPOINTS
 	trace_mlx5e_configure_flower(f);
+#endif
 	err = mlx5e_tc_add_flow(priv, f, flags, dev, &flow);
 	if (err)
 		goto out;
@@ -4322,6 +4521,9 @@ out_rcu:
 	rcu_read_unlock();
 	goto out;
 }
+#ifdef CONFIG_COMPAT_CLS_FLOWER_MOD
+EXPORT_SYMBOL(mlx5e_configure_flower);
+#endif
 
 static bool same_flow_direction(struct mlx5e_tc_flow *flow, int flags)
 {
@@ -4357,7 +4559,9 @@ int mlx5e_delete_flower(struct net_devic
 	rhashtable_remove_fast(tc_ht, &flow->node, tc_ht_params);
 	rcu_read_unlock();
 
+#ifndef MLX_DISABLE_TRACEPOINTS
 	trace_mlx5e_delete_flower(f);
+#endif
 	mlx5e_flow_put(priv, flow);
 
 	put_esw_tc_refcnt(esw);
@@ -4367,6 +4571,9 @@ errout:
 	rcu_read_unlock();
 	return err;
 }
+#ifdef CONFIG_COMPAT_CLS_FLOWER_MOD
+EXPORT_SYMBOL(mlx5e_delete_flower);
+#endif
 
 int mlx5e_stats_flower(struct net_device *dev, struct mlx5e_priv *priv,
 		       struct flow_cls_offload *f, unsigned long flags)
@@ -4376,11 +4583,21 @@ int mlx5e_stats_flower(struct net_device
 	struct mlx5_eswitch *peer_esw;
 	struct mlx5e_tc_flow *flow;
 	struct mlx5_fc *counter;
+#if !defined(HAVE_TC_CLS_FLOWER_OFFLOAD_HAS_STATS_FIELD) && \
+    !defined(HAVE_TCF_EXTS_STATS_UPDATE)
+	struct tc_action *a;
+	LIST_HEAD(actions);
+#endif
 	u64 lastuse = 0;
 	u64 packets = 0;
 	u64 bytes = 0;
 	int err = 0;
 
+#if defined(CONFIG_COMPAT_CLS_FLOWER_MOD) || \
+    (!defined(HAVE_TC_BLOCK_OFFLOAD) && !defined(HAVE_FLOW_BLOCK_OFFLOAD))
+	get_new_flags(priv, &flags);
+#endif
+
 	rcu_read_lock();
 	flow = mlx5e_flow_get(rhashtable_lookup(tc_ht, &f->cookie,
 						tc_ht_params));
@@ -4427,12 +4644,47 @@ int mlx5e_stats_flower(struct net_device
 no_peer_counter:
 	mlx5_devcom_release_peer_data(devcom, MLX5_DEVCOM_ESW_OFFLOADS);
 out:
+#ifdef HAVE_FLOW_STATS_UPDATE_5_PARAMS
+	flow_stats_update(&f->stats, bytes, packets, lastuse,
+			  FLOW_ACTION_HW_STATS_DELAYED);
+#elif defined(HAVE_TC_CLS_FLOWER_OFFLOAD_HAS_STATS_FIELD)
 	flow_stats_update(&f->stats, bytes, packets, lastuse);
+#elif defined(HAVE_TCF_EXTS_STATS_UPDATE)
+	tcf_exts_stats_update(f->exts, bytes, packets, lastuse);
+#else
+	preempt_disable();
+
+#ifdef HAVE_TCF_EXTS_TO_LIST
+	tcf_exts_to_list(f->exts, &actions);
+	list_for_each_entry(a, &actions, list)
+#else
+	tc_for_each_action(a, f->exts)
+#endif
+#ifdef HAVE_TCF_ACTION_STATS_UPDATE
+		tcf_action_stats_update(a, bytes, packets, lastuse);
+#else
+	{
+		struct tcf_act_hdr *h = a->priv;
+
+		spin_lock(&h->tcf_lock);
+		h->tcf_tm.lastuse = max_t(u64, h->tcf_tm.lastuse, lastuse);
+		h->tcf_bstats.bytes += bytes;
+		h->tcf_bstats.packets += packets;
+		spin_unlock(&h->tcf_lock);
+	}
+#endif
+	preempt_enable();
+#endif /* HAVE_TC_CLS_FLOWER_OFFLOAD_HAS_STATS_FIELD */
+#ifndef MLX_DISABLE_TRACEPOINTS
 	trace_mlx5e_stats_flower(f);
+#endif
 errout:
 	mlx5e_flow_put(priv, flow);
 	return err;
 }
+#ifdef CONFIG_COMPAT_CLS_FLOWER_MOD
+EXPORT_SYMBOL(mlx5e_stats_flower);
+#endif
 
 static void mlx5e_tc_hairpin_update_dead_peer(struct mlx5e_priv *priv,
 					      struct mlx5e_priv *peer_priv)
@@ -4600,6 +4852,11 @@ void mlx5e_tc_esw_cleanup(struct rhashta
 
 	rhashtable_free_and_destroy(tc_ht, _mlx5e_tc_del_flow, NULL);
 
+#if !defined (CONFIG_COMPAT_CLS_FLOWER_MOD) && \
+    !defined(HAVE_TC_BLOCK_OFFLOAD) && !defined(HAVE_FLOW_BLOCK_OFFLOAD)
+	tc_ht->tbl = NULL;
+#endif
+
 	uplink_priv = container_of(tc_ht, struct mlx5_rep_uplink_priv, tc_ht);
 	mapping_destroy(uplink_priv->tunnel_enc_opts_mapping);
 	mapping_destroy(uplink_priv->tunnel_mapping);
@@ -4637,10 +4894,28 @@ void mlx5e_tc_reoffload_flows_work(struc
 	mutex_unlock(&rpriv->unready_flows_lock);
 }
 
+#if defined(HAVE_NDO_SETUP_TC_TAKES_TC_SETUP_TYPE) || defined(HAVE_NDO_SETUP_TC_RH_EXTENDED)
+#ifdef CONFIG_MLX5_ESWITCH
+#if defined(HAVE_TC_BLOCK_OFFLOAD) || defined(HAVE_FLOW_BLOCK_OFFLOAD)
 static int mlx5e_setup_tc_cls_flower(struct mlx5e_priv *priv,
+#else
+int mlx5e_setup_tc_cls_flower(struct net_device *dev,
+#endif
 				     struct flow_cls_offload *cls_flower,
 				     unsigned long flags)
 {
+#ifndef HAVE_TC_CLS_CAN_OFFLOAD_AND_CHAIN0
+#ifdef HAVE_TC_BLOCK_OFFLOAD
+	if (cls_flower->common.chain_index)
+#else
+	struct mlx5e_priv *priv = netdev_priv(dev);
+
+	if (!is_classid_clsact_ingress(cls_flower->common.classid) ||
+	    cls_flower->common.chain_index)
+#endif
+		return -EOPNOTSUPP;
+#endif
+
 	switch (cls_flower->command) {
 	case FLOW_CLS_REPLACE:
 		return mlx5e_configure_flower(priv->netdev, priv, cls_flower,
@@ -4656,6 +4931,7 @@ static int mlx5e_setup_tc_cls_flower(str
 	}
 }
 
+#if defined(HAVE_TC_BLOCK_OFFLOAD) || defined(HAVE_FLOW_BLOCK_OFFLOAD)
 int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
 			    void *cb_priv)
 {
@@ -4665,6 +4941,11 @@ int mlx5e_setup_tc_block_cb(enum tc_setu
 	if (!priv->netdev || !netif_device_present(priv->netdev))
 		return -EOPNOTSUPP;
 
+#if defined(HAVE_TC_CLS_OFFLOAD_EXTACK) && !defined(CONFIG_COMPAT_PRIO_CHAIN_SUPPORT)
+	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
+		return -EOPNOTSUPP;
+#endif
+
 	if (mlx5e_is_uplink_rep(priv))
 		flags |= MLX5_TC_FLAG(ESW_OFFLOAD);
 	else
@@ -4677,3 +4958,33 @@ int mlx5e_setup_tc_block_cb(enum tc_setu
 		return -EOPNOTSUPP;
 	}
 }
+
+#ifndef HAVE_FLOW_BLOCK_CB_SETUP_SIMPLE
+int mlx5e_setup_tc_block(struct net_device *dev,
+			 struct tc_block_offload *f)
+{
+	struct mlx5e_priv *priv = netdev_priv(dev);
+
+	if (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+		return -EOPNOTSUPP;
+
+	switch (f->command) {
+	case TC_BLOCK_BIND:
+		return tcf_block_cb_register(f->block, mlx5e_setup_tc_block_cb,
+					     priv, priv
+#ifdef HAVE_TC_BLOCK_OFFLOAD_EXTACK
+					     , f->extack
+#endif
+					    );
+	case TC_BLOCK_UNBIND:
+		tcf_block_cb_unregister(f->block, mlx5e_setup_tc_block_cb,
+					priv);
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif /* HAVE_FLOW_BLOCK_CB_SETUP_SIMPLE */
+#endif /* HAVE_TC_BLOCK_OFFLOAD || HAVE_FLOW_BLOCK_OFFLOAD */
+#endif /*ESWITCH */
+#endif
