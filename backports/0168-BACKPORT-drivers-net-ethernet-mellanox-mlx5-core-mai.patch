From: Alaa Hleihel <alaa@mellanox.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/main.c

Change-Id: Idda58f581655a7a02d2781d4ccafef984276daee
---
 drivers/net/ethernet/mellanox/mlx5/core/main.c | 113 ++++++++++++++++++++++++-
 1 file changed, 109 insertions(+), 4 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -81,6 +81,9 @@
 MODULE_AUTHOR("Eli Cohen <eli@mellanox.com>");
 MODULE_DESCRIPTION("Mellanox 5th generation network adapters (ConnectX series) core driver");
 MODULE_LICENSE("Dual BSD/GPL");
+#ifdef RETPOLINE_MLNX
+MODULE_INFO(retpoline, "Y");
+#endif
 MODULE_VERSION(DRIVER_VERSION);
 
 unsigned int mlx5_core_debug_mask;
@@ -264,8 +267,10 @@ static struct mlx5_profile profile[] = {
 #define FW_PRE_INIT_TIMEOUT_MILI	120000
 #define FW_INIT_WARN_MESSAGE_INTERVAL	20000
 
+#ifdef HAVE_PNV_PCI_AS_NOTIFY
 static void mlx5_as_notify_init(struct mlx5_core_dev *dev);
 static void mlx5_as_notify_cleanup(struct mlx5_core_dev *dev);
+#endif
 
 static int wait_fw_init(struct mlx5_core_dev *dev, u32 max_wait_mili,
 			u32 warn_time_mili)
@@ -431,6 +436,9 @@ static int mlx5_alloc_irq_vectors(struct
 	int num_eqs;
 	int nvec;
 	int err;
+#ifndef HAVE_PCI_IRQ_API
+	int i;
+#endif
 
 	if (max_num_eq) {
 		num_eqs = max_num_eq;
@@ -456,9 +464,21 @@ static int mlx5_alloc_irq_vectors(struct
 	} else {
 		priv->irq_info = kcalloc(nvec, sizeof(*priv->irq_info),
 					 GFP_KERNEL);
+#ifdef HAVE_PCI_IRQ_API
 		if (!priv->irq_info)
 			return -ENOMEM;
+#else
+		priv->msix_arr = kcalloc(nvec, sizeof(*priv->msix_arr), GFP_KERNEL);
+		if (!priv->msix_arr || !priv->irq_info) {
+			err = -ENOMEM;
+			goto err_free_irq_info;
+		}
+
+		for (i = 0; i < nvec; i++)
+			 priv->msix_arr[i].entry = i;
+#endif
 
+#ifdef HAVE_PCI_IRQ_API
 		nvec = pci_alloc_irq_vectors(dev->pdev,
 					     comp_base_vec + 1, nvec,
 					     PCI_IRQ_MSIX);
@@ -467,12 +487,40 @@ static int mlx5_alloc_irq_vectors(struct
 			goto err_free_irq_info;
 		}
 		table->num_comp_vectors = nvec - comp_base_vec;
+#else /* HAVE_PCI_IRQ_API */
+#ifdef HAVE_PCI_ENABLE_MSIX_RANGE
+		nvec = pci_enable_msix_range(dev->pdev, priv->msix_arr,
+					     comp_base_vec + 1, nvec);
+		if (nvec < 0) {
+			err = nvec;
+			goto err_free_irq_info;
+		}
+
+		table->num_comp_vectors = nvec - comp_base_vec;
+#else /* HAVE_PCI_ENABLE_MSIX_RANGE */
+retry:
+		table->num_comp_vectors = nvec - comp_base_vec;
+		err = pci_enable_msix(dev->pdev, priv->msix_arr, nvec);
+		if (err == 0) {
+			return 0;
+		} else if (err < 0) {
+			goto err_free_irq_info;
+		} else if (err > 2) {
+			nvec = err;
+			goto retry;
+		}
+		mlx5_core_dbg(dev, "received %d MSI vectors out of %d requested\n", err, nvec);
+#endif /* HAVE_PCI_ENABLE_MSIX_RANGE */
+#endif /* HAVE_PCI_IRQ_API */
 	}
 
 	return 0;
 
 err_free_irq_info:
 	kfree(priv->irq_info);
+#ifndef HAVE_PCI_IRQ_API
+	kfree(priv->msix_arr);
+#endif
 	return err;
 }
 
@@ -482,7 +530,13 @@ static void mlx5_free_irq_vectors(struct
 
 	if (mlx5_core_is_sf(dev))
 		return;
+
+#ifdef HAVE_PCI_IRQ_API
 	pci_free_irq_vectors(dev->pdev);
+#else
+	pci_disable_msix(dev->pdev);
+	kfree(priv->msix_arr);
+#endif
 	kfree(priv->irq_info);
 }
 
@@ -896,7 +950,14 @@ static int mlx5_irq_set_affinity_hint(st
 {
 	struct mlx5_priv *priv  = &mdev->priv;
 	int vecidx = MLX5_EQ_VEC_COMP_BASE + i;
+#ifdef HAVE_IRQ_SET_AFFINITY_HINT
+#ifdef HAVE_PCI_IRQ_API
 	int irq = pci_irq_vector(mdev->pdev, vecidx);
+#else
+	struct msix_entry *msix = priv->msix_arr;
+	int irq                 = msix[vecidx].vector;
+#endif
+#endif
 
 	if (!zalloc_cpumask_var(&priv->irq_info[vecidx].mask, GFP_KERNEL)) {
 		mlx5_core_warn(mdev, "zalloc_cpumask_var failed");
@@ -906,9 +967,11 @@ static int mlx5_irq_set_affinity_hint(st
 	cpumask_set_cpu(cpumask_local_spread(i, priv->numa_node),
 			priv->irq_info[vecidx].mask);
 
-	if (IS_ENABLED(CONFIG_SMP) &&
-	    irq_set_affinity_hint(irq, priv->irq_info[vecidx].mask))
-		mlx5_core_warn(mdev, "irq_set_affinity_hint failed, irq 0x%.4x", irq);
+#ifdef HAVE_IRQ_SET_AFFINITY_HINT
+ 	if (IS_ENABLED(CONFIG_SMP) &&
+ 	    irq_set_affinity_hint(irq, priv->irq_info[vecidx].mask))
+ 		mlx5_core_warn(mdev, "irq_set_affinity_hint failed, irq 0x%.4x", irq);
+#endif
 
 	return 0;
 }
@@ -917,9 +980,18 @@ static void mlx5_irq_clear_affinity_hint
 {
 	int vecidx = MLX5_EQ_VEC_COMP_BASE + i;
 	struct mlx5_priv *priv  = &mdev->priv;
+#ifdef HAVE_IRQ_SET_AFFINITY_HINT
+#ifdef HAVE_PCI_IRQ_API
 	int irq = pci_irq_vector(mdev->pdev, vecidx);
+#else
+	struct msix_entry *msix = priv->msix_arr;
+	int irq                 = msix[vecidx].vector;
+#endif
+#endif
 
+#ifdef HAVE_IRQ_SET_AFFINITY_HINT
 	irq_set_affinity_hint(irq, NULL);
+#endif
 	free_cpumask_var(priv->irq_info[vecidx].mask);
 }
 
@@ -1098,9 +1170,14 @@ static int alloc_comp_eqs(struct mlx5_co
 
 #ifdef CONFIG_RFS_ACCEL
 		if (!mlx5_core_is_sf(dev))
+#ifdef HAVE_PCI_IRQ_API
 			irq_cpu_rmap_add(dev->rmap,
 					 pci_irq_vector(dev->pdev,
 							comp_base_vec + i));
+#else
+			irq_cpu_rmap_add(dev->rmap,
+					 dev->priv.msix_arr[i + comp_base_vec].vector);
+#endif
 #endif
 		snprintf(name, MLX5_MAX_IRQ_NAME,
 			 MLX5_DEFAULT_COMP_IRQ_NAME, i);
@@ -1547,8 +1624,10 @@ static int mlx5_function_setup(struct ml
 		goto reclaim_boot_pages;
 	}
 
+#ifdef HAVE_PNV_PCI_AS_NOTIFY
 	/* Treat as_notify as best effort feature */
 	mlx5_as_notify_init(dev);
+#endif
 
 	err = mlx5_pagealloc_start(dev);
 	if (err) {
@@ -1579,7 +1658,9 @@ static int mlx5_function_setup(struct ml
 stop_health:
 	mlx5_stop_health_poll(dev, boot);
 err_pagealloc_stop:
+#ifdef HAVE_PNV_PCI_AS_NOTIFY
 	mlx5_as_notify_cleanup(dev);
+#endif
 	mlx5_pagealloc_stop(dev);
 reclaim_boot_pages:
 	mlx5_reclaim_startup_pages(dev);
@@ -1601,7 +1682,9 @@ static int mlx5_function_teardown(struct
 		mlx5_core_err(dev, "tear_down_hca failed, skip cleanup\n");
 		return err;
 	}
+#ifdef HAVE_PNV_PCI_AS_NOTIFY
 	mlx5_as_notify_cleanup(dev);
+#endif
 	mlx5_pagealloc_stop(dev);
 	mlx5_reclaim_startup_pages(dev);
 	mlx5_core_disable_hca(dev, 0);
@@ -1663,11 +1746,13 @@ static int mlx5_load(struct mlx5_core_de
 		goto err_ipsec_start;
 	}
 
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	err = mlx5_accel_tls_init(dev);
 	if (err) {
 		mlx5_core_err(dev, "TLS device start failed %d\n", err);
 		goto err_tls_start;
 	}
+#endif
 
 	err = mlx5_init_fs(dev);
 	if (err) {
@@ -1713,9 +1798,11 @@ err_sriov:
 	mlx5_cleanup_fs(dev);
 
 err_fs:
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	mlx5_accel_tls_cleanup(dev);
 
 err_tls_start:
+#endif
 	mlx5_accel_ipsec_cleanup(dev);
 
 err_ipsec_start:
@@ -1749,7 +1836,9 @@ static void mlx5_unload(struct mlx5_core
 	mlx5_diag_cnt_cleanup(dev);
 	mlx5_sriov_detach(dev);
 	mlx5_cleanup_fs(dev);
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	mlx5_accel_tls_cleanup(dev);
+#endif
 	mlx5_accel_ipsec_cleanup(dev);
 	mlx5_fpga_device_stop(dev);
 	mlx5_irq_clear_affinity_hints(dev);
@@ -1903,7 +1992,9 @@ int mlx5_unload_one(struct mlx5_core_dev
 	mlx5_sriov_detach(dev);
 	mlx5_cleanup_fs(dev);
 	mlx5_accel_ipsec_cleanup(dev);
+#ifdef HAVE_UAPI_LINUX_TLS_H
 	mlx5_accel_tls_cleanup(dev);
+#endif
 	mlx5_fpga_device_stop(dev);
 	mlx5_irq_clear_affinity_hints(dev);
 	free_comp_eqs(dev);
@@ -1930,12 +2021,18 @@ struct mlx5_core_event_handler {
 
 static const struct devlink_ops mlx5_devlink_ops = {
 #ifdef CONFIG_MLX5_ESWITCH
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET
 	.eswitch_mode_set = mlx5_devlink_eswitch_mode_set,
 	.eswitch_mode_get = mlx5_devlink_eswitch_mode_get,
+#endif /* HAVE_DEVLINK_HAS_ESWITCH_MODE_GET_SET */
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_INLINE_MODE_GET_SET
 	.eswitch_inline_mode_set = mlx5_devlink_eswitch_inline_mode_set,
 	.eswitch_inline_mode_get = mlx5_devlink_eswitch_inline_mode_get,
+#endif /* HAVE_DEVLINK_HAS_ESWITCH_INLINE_MODE_GET_SET */
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_ENCAP_MODE_SET
 	.eswitch_encap_mode_set = mlx5_devlink_eswitch_encap_mode_set,
 	.eswitch_encap_mode_get = mlx5_devlink_eswitch_encap_mode_get,
+#endif /* HAVE_DEVLINK_HAS_ESWITCH_ENCAP_MODE_SET */
 #endif
 };
 
@@ -2238,6 +2335,7 @@ static void capi_cleanup(struct mlx5_cor
 }
 #endif
 
+#ifdef HAVE_PNV_PCI_AS_NOTIFY
 static void mlx5_as_notify_init(struct mlx5_core_dev *dev)
 {
 #ifdef HAVE_PNV_PCI_AS_NOTIFY
@@ -2280,11 +2378,12 @@ static void mlx5_as_notify_init(struct m
 }
 
 static void mlx5_as_notify_cleanup(struct mlx5_core_dev *dev) { }
+#endif
 
 int mlx5_mdev_init(struct mlx5_core_dev *dev, int profile_idx)
 {
 	struct mlx5_priv *priv = &dev->priv;
-	int err;
+	int err = 0;
 
 	dev->event = mlx5_core_event;
 	dev->profile = &profile[profile_idx];
@@ -2666,7 +2765,11 @@ static void mlx5_pci_resume(struct pci_d
 		mlx5_core_info(dev, "%s: device recovered\n", __func__);
 }
 
+#ifdef CONFIG_COMPAT_IS_CONST_PCI_ERROR_HANDLERS
 static const struct pci_error_handlers mlx5_err_handler = {
+#else
+static struct pci_error_handlers mlx5_err_handler = {
+#endif
 	.error_detected = mlx5_pci_err_detected,
 	.slot_reset	= mlx5_pci_slot_reset,
 	.resume		= mlx5_pci_resume
@@ -2746,7 +2849,9 @@ static struct pci_driver mlx5_core_drive
 	.remove         = remove_one,
 	.shutdown	= shutdown,
 	.err_handler	= &mlx5_err_handler,
+#ifdef HAVE_PCI_DRIVER_SRIOV_CONFIGURE
 	.sriov_configure   = mlx5_core_sriov_configure,
+#endif
 };
 
 static void mlx5_core_verify_params(void)
