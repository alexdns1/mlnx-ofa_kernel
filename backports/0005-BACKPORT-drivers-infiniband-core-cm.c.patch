From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/infiniband/core/cm.c

Change-Id: I708f243ef441c8c7302e0680882b4376adc83a3d
---
 drivers/infiniband/core/cm.c | 77 ++++++++++++++++++++++++++++++++++++
 1 file changed, 77 insertions(+)

--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@ -27,11 +27,16 @@
 #include <rdma/ib_cm.h>
 #include "cm_msgs.h"
 #include "core_priv.h"
+#ifdef HAVE_TRACE_EVENTS_H
 #include "cm_trace.h"
+#endif
 
 MODULE_AUTHOR("Sean Hefty");
 MODULE_DESCRIPTION("InfiniBand CM");
 MODULE_LICENSE("Dual BSD/GPL");
+#ifdef RETPOLINE_MLNX
+MODULE_INFO(retpoline, "Y");
+#endif
 
 static const char * const ibcm_rej_reason_strs[] = {
 	[IB_CM_REJ_NO_QP]			= "no QP",
@@ -1600,7 +1605,9 @@ int ib_send_cm_req(struct ib_cm_id *cm_i
 	cm_id_priv->local_qpn = cpu_to_be32(IBA_GET(CM_REQ_LOCAL_QPN, req_msg));
 	cm_id_priv->rq_psn = cpu_to_be32(IBA_GET(CM_REQ_STARTING_PSN, req_msg));
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_req(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		goto out_free;
@@ -1647,9 +1654,11 @@ static int cm_issue_rej(struct cm_port *
 		IBA_SET_MEM(CM_REJ_ARI, rej_msg, ari, ari_length);
 	}
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_issue_rej(
 		IBA_GET(CM_REJ_LOCAL_COMM_ID, rcv_msg),
 		IBA_GET(CM_REJ_REMOTE_COMM_ID, rcv_msg));
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		cm_free_response_msg(msg);
@@ -2001,7 +2010,9 @@ static void cm_dup_req_handler(struct cm
 	}
 	spin_unlock_irq(&cm_id_priv->lock);
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_dup_req(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		goto free;
@@ -2166,7 +2177,9 @@ static int cm_req_handler(struct cm_work
 
 	listen_cm_id_priv = cm_match_req(work, cm_id_priv);
 	if (!listen_cm_id_priv) {
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_no_listener_err(&cm_id_priv->id);
+#endif
 		cm_id_priv->id.state = IB_CM_IDLE;
 		ret = -EINVAL;
 		goto destroy;
@@ -2314,7 +2327,9 @@ int ib_send_cm_rep(struct ib_cm_id *cm_i
 	spin_lock_irqsave(&cm_id_priv->lock, flags);
 	if (cm_id->state != IB_CM_REQ_RCVD &&
 	    cm_id->state != IB_CM_MRA_REQ_SENT) {
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_send_rep_err(cm_id_priv->id.local_id, cm_id->state);
+#endif
 		ret = -EINVAL;
 		goto out;
 	}
@@ -2330,7 +2345,9 @@ int ib_send_cm_rep(struct ib_cm_id *cm_i
 	msg->timeout_ms = cm_id_priv->timeout_ms;
 	msg->context[1] = (void *) (unsigned long) IB_CM_REP_SENT;
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_rep(cm_id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		goto out_free;
@@ -2391,7 +2408,9 @@ int ib_send_cm_rtu(struct ib_cm_id *cm_i
 	spin_lock_irqsave(&cm_id_priv->lock, flags);
 	if (cm_id->state != IB_CM_REP_RCVD &&
 	    cm_id->state != IB_CM_MRA_REP_SENT) {
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_send_cm_rtu_err(cm_id);
+#endif
 		ret = -EINVAL;
 		goto error;
 	}
@@ -2405,7 +2424,9 @@ int ib_send_cm_rtu(struct ib_cm_id *cm_i
 	cm_format_rtu((struct cm_rtu_msg *) msg->mad, cm_id_priv,
 		      private_data, private_data_len);
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_rtu(cm_id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret) {
 		spin_unlock_irqrestore(&cm_id_priv->lock, flags);
@@ -2487,7 +2508,9 @@ static void cm_dup_rep_handler(struct cm
 		goto unlock;
 	spin_unlock_irq(&cm_id_priv->lock);
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_dup_rep(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		goto free;
@@ -2511,8 +2534,10 @@ static int cm_rep_handler(struct cm_work
 		cpu_to_be32(IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg)), 0);
 	if (!cm_id_priv) {
 		cm_dup_rep_handler(work);
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_remote_no_priv_err(
 			 IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg));
+#endif
 		return -EINVAL;
 	}
 
@@ -2525,10 +2550,12 @@ static int cm_rep_handler(struct cm_work
 		break;
 	default:
 		ret = -EINVAL;
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_rep_unknown_err(
 			IBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg),
 			IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg),
 			cm_id_priv->id.state);
+#endif
 		spin_unlock_irq(&cm_id_priv->lock);
 		goto error;
 	}
@@ -2545,8 +2572,10 @@ static int cm_rep_handler(struct cm_work
 		spin_unlock(&cm.lock);
 		spin_unlock_irq(&cm_id_priv->lock);
 		ret = -EINVAL;
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_insert_failed_err(
 			 IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg));
+#endif
 		goto error;
 	}
 	/* Check for a stale connection. */
@@ -2562,9 +2591,11 @@ static int cm_rep_handler(struct cm_work
 			     IB_CM_REJ_STALE_CONN, CM_MSG_RESPONSE_REP,
 			     NULL, 0);
 		ret = -EINVAL;
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_staleconn_err(
 			IBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg),
 			IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg));
+#endif
 
 		if (cur_cm_id_priv) {
 			ib_send_cm_dreq(&cur_cm_id_priv->id, NULL, 0);
@@ -2690,7 +2721,9 @@ static int cm_send_dreq_locked(struct cm
 		return -EINVAL;
 
 	if (cm_id_priv->id.state != IB_CM_ESTABLISHED) {
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_dreq_skipped(&cm_id_priv->id);
+#endif
 		return -EINVAL;
 	}
 
@@ -2709,7 +2742,9 @@ static int cm_send_dreq_locked(struct cm
 	msg->timeout_ms = cm_id_priv->timeout_ms;
 	msg->context[1] = (void *) (unsigned long) IB_CM_DREQ_SENT;
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_dreq(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret) {
 		cm_enter_timewait(cm_id_priv);
@@ -2764,7 +2799,9 @@ static int cm_send_drep_locked(struct cm
 		return -EINVAL;
 
 	if (cm_id_priv->id.state != IB_CM_DREQ_RCVD) {
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_send_drep_err(&cm_id_priv->id);
+#endif
 		kfree(private_data);
 		return -EINVAL;
 	}
@@ -2779,7 +2816,9 @@ static int cm_send_drep_locked(struct cm
 	cm_format_drep((struct cm_drep_msg *) msg->mad, cm_id_priv,
 		       private_data, private_data_len);
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_drep(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret) {
 		cm_free_msg(msg);
@@ -2829,9 +2868,11 @@ static int cm_issue_drep(struct cm_port
 	IBA_SET(CM_DREP_LOCAL_COMM_ID, drep_msg,
 		IBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg));
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_issue_drep(
 		IBA_GET(CM_DREQ_LOCAL_COMM_ID, dreq_msg),
 		IBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg));
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		cm_free_response_msg(msg);
@@ -2853,9 +2894,11 @@ static int cm_dreq_handler(struct cm_wor
 		atomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].
 				counter[CM_DREQ_COUNTER]);
 		cm_issue_drep(work->port, work->mad_recv_wc);
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_no_priv_err(
 			IBA_GET(CM_DREQ_LOCAL_COMM_ID, dreq_msg),
 			IBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg));
+#endif
 		return -EINVAL;
 	}
 
@@ -2899,7 +2942,9 @@ static int cm_dreq_handler(struct cm_wor
 				counter[CM_DREQ_COUNTER]);
 		goto unlock;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_dreq_unknown_err(&cm_id_priv->id);
+#endif
 		goto unlock;
 	}
 	cm_id_priv->id.state = IB_CM_DREQ_RCVD;
@@ -2984,11 +3029,15 @@ static int cm_send_rej_locked(struct cm_
 			      state);
 		break;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_send_unknown_rej_err(&cm_id_priv->id);
+#endif
 		return -EINVAL;
 	}
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_rej(&cm_id_priv->id, reason);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret) {
 		cm_free_msg(msg);
@@ -3097,7 +3146,9 @@ static int cm_rej_handler(struct cm_work
 		}
 		fallthrough;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_rej_unknown_err(&cm_id_priv->id);
+#endif
 		spin_unlock_irq(&cm_id_priv->lock);
 		goto out;
 	}
@@ -3153,7 +3204,9 @@ int ib_send_cm_mra(struct ib_cm_id *cm_i
 		}
 		fallthrough;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_send_mra_unknown_err(&cm_id_priv->id);
+#endif
 		ret = -EINVAL;
 		goto error_unlock;
 	}
@@ -3168,7 +3221,9 @@ int ib_send_cm_mra(struct ib_cm_id *cm_i
 		cm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,
 			      msg_response, service_timeout,
 			      private_data, private_data_len);
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_send_mra(cm_id);
+#endif
 		ret = ib_post_send_mad(msg, NULL);
 		if (ret)
 			goto error_free_msg;
@@ -3260,7 +3315,9 @@ static int cm_mra_handler(struct cm_work
 				counter[CM_MRA_COUNTER]);
 		fallthrough;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_mra_unknown_err(&cm_id_priv->id);
+#endif
 		goto out;
 	}
 
@@ -3549,7 +3606,9 @@ int ib_send_cm_sidr_req(struct ib_cm_id
 	msg->timeout_ms = cm_id_priv->timeout_ms;
 	msg->context[1] = (void *)(unsigned long)IB_CM_SIDR_REQ_SENT;
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_sidr_req(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret)
 		goto out_free;
@@ -3712,7 +3771,9 @@ static int cm_send_sidr_rep_locked(struc
 
 	cm_format_sidr_rep((struct cm_sidr_rep_msg *) msg->mad, cm_id_priv,
 			   param);
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_send_sidr_rep(&cm_id_priv->id);
+#endif
 	ret = ib_post_send_mad(msg, NULL);
 	if (ret) {
 		cm_free_msg(msg);
@@ -3814,7 +3875,9 @@ static void cm_process_send_error(struct
 	    wc_status == IB_WC_WR_FLUSH_ERR)
 		goto out_unlock;
 
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 	trace_icm_mad_send_err(state, wc_status);
+#endif
 	switch (state) {
 	case IB_CM_REQ_SENT:
 	case IB_CM_MRA_REQ_RCVD:
@@ -3931,7 +3994,9 @@ static void cm_work_handler(struct work_
 		ret = cm_timewait_handler(work);
 		break;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_handler_err(work->cm_event.event);
+#endif
 		ret = -EINVAL;
 		break;
 	}
@@ -3966,7 +4031,9 @@ static int cm_establish(struct ib_cm_id
 		ret = -EISCONN;
 		break;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_establish_err(cm_id);
+#endif
 		ret = -EINVAL;
 		break;
 	}
@@ -4155,7 +4222,9 @@ static int cm_init_qp_init_attr(struct c
 		ret = 0;
 		break;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_qp_init_err(&cm_id_priv->id);
+#endif
 		ret = -EINVAL;
 		break;
 	}
@@ -4204,7 +4273,9 @@ static int cm_init_qp_rtr_attr(struct cm
 		ret = 0;
 		break;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_qp_rtr_err(&cm_id_priv->id);
+#endif
 		ret = -EINVAL;
 		break;
 	}
@@ -4266,7 +4337,9 @@ static int cm_init_qp_rts_attr(struct cm
 		ret = 0;
 		break;
 	default:
+#if defined(HAVE_TRACE_EVENTS_H) && !defined(MLX_DISABLE_TRACEPOINTS)
 		trace_icm_qp_rts_err(&cm_id_priv->id);
+#endif
 		ret = -EINVAL;
 		break;
 	}
@@ -4313,7 +4386,11 @@ static ssize_t cm_show_counter(struct ko
 			  atomic_long_read(&group->counter[cm_attr->index]));
 }
 
+#ifdef CONFIG_COMPAT_IS_CONST_KOBJECT_SYSFS_OPS
 static const struct sysfs_ops cm_counter_ops = {
+#else
+static struct sysfs_ops cm_counter_ops = {
+#endif
 	.show = cm_show_counter
 };
 
