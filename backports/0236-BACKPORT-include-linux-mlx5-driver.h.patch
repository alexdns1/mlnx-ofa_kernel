From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: include/linux/mlx5/driver.h

Change-Id: I899147176495656b2c12518d7b649f81090a6b72
---
 include/linux/mlx5/driver.h | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -33,6 +33,8 @@
 #ifndef MLX5_DRIVER_H
 #define MLX5_DRIVER_H
 
+#include "../../../compat/config.h"
+
 #include <linux/kernel.h>
 #include <linux/completion.h>
 #include <linux/pci.h>
@@ -56,6 +58,9 @@
 #include <linux/timecounter.h>
 #include <linux/ptp_clock_kernel.h>
 #include <net/devlink.h>
+#include <linux/net_tstamp.h>
+#include <linux/llist.h>
+
 
 #define MLX5_ADEV_NAME "mlx5_core"
 
@@ -474,9 +479,11 @@ struct mlx5_core_health {
 	struct mlx5_fw_crdump		*crdump;
 	struct mlx5_health_recoveries	recoveries;
 	struct work_struct		fatal_report_work;
+#ifdef HAVE_DEVLINK_HEALTH_REPORT_SUPPORT
 	struct work_struct		report_work;
 	struct devlink_health_reporter *fw_reporter;
 	struct devlink_health_reporter *fw_fatal_reporter;
+#endif /* HAVE_DEVLINK_HEALTH_REPORT_SUPPORT */
 	struct delayed_work		update_fw_log_ts_work;
 };
 
@@ -677,6 +684,9 @@ struct mlx5_priv {
 	/* IRQ table valid only for real pci devices PF or VF */
 	struct mlx5_irq_table   *irq_table;
 	struct mlx5_eq_table	*eq_table;
+#ifndef HAVE_PCI_IRQ_API
+	struct msix_entry       *msix_arr;
+#endif
 
 	/* pages stuff */
 	struct mlx5_nb          pg_nb;
@@ -885,9 +895,11 @@ struct mlx5_clock {
 	struct mlx5_nb             pps_nb;
 	seqlock_t                  lock;
 	struct hwtstamp_config     hwtstamp_config;
+#if (defined (CONFIG_PTP_1588_CLOCK) || defined(CONFIG_PTP_1588_CLOCK_MODULE))
 	struct ptp_clock          *ptp;
 	struct ptp_clock_info      ptp_info;
 	struct mlx5_pps            pps_info;
+#endif
 	struct mlx5_timer          timer;
 };
 
@@ -1060,8 +1072,13 @@ struct mlx5_cmd_work_ent {
 	int			page_queue;
 	u8			status;
 	u8			token;
+#ifdef HAVE_KTIME_GET_NS
 	u64			ts1;
 	u64			ts2;
+#else
+	struct timespec		ts1;
+	struct timespec		ts2;
+#endif
 	u16			op;
 	bool			polling;
 	/* Track the max comp handlers */
@@ -1196,7 +1213,7 @@ void mlx5_cmd_allowed_opcode(struct mlx5
 struct mlx5_async_ctx {
 	struct mlx5_core_dev *dev;
 	atomic_t num_inflight;
-	struct wait_queue_head wait;
+	wait_queue_head_t wait;
 };
 
 struct mlx5_async_work;
@@ -1508,6 +1525,7 @@ enum {
 
 static inline bool mlx5_is_roce_init_enabled(struct mlx5_core_dev *dev)
 {
+#if defined(HAVE_DEVLINK_PARAM) && defined(HAVE_DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE)
 	struct devlink *devlink = priv_to_devlink(dev);
 	union devlink_param_value val;
 	int err;
@@ -1516,6 +1534,9 @@ static inline bool mlx5_is_roce_init_ena
 						 DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,
 						 &val);
 	return err ? MLX5_CAP_GEN(dev, roce) : val.vbool;
+#else
+	return dev->roce.enabled && MLX5_CAP_GEN(dev, roce);
+#endif
 }
 
 /* MLX5 Diagnostics */
