From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT:
 drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c

Change-Id: Id807fcdfa6a5081128b5168997d3a3af3b667907
---
 .../mellanox/mlx5/core/en_accel/ipsec_rxtx.c       | 75 +++++++++++++++++++++-
 1 file changed, 72 insertions(+), 3 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_rxtx.c
@@ -150,7 +150,11 @@ static void mlx5e_ipsec_set_swp(struct s
 	 * SWP:      OutL3                   InL3  InL4
 	 * Pkt: MAC  IP     ESP  UDP  VXLAN  IP    L4
 	 */
+#ifdef HAVE_XFRM_OFFLOAD_INNER_IPPROTO
+	u8 inner_ipproto = xo->inner_ipproto;
+#else
 	u8 inner_ipproto = 0;
+#endif
 
 	/* Shared settings */
 	eseg->swp_outer_l3_offset = skb_network_offset(skb) / 2;
@@ -272,6 +276,26 @@ static void mlx5e_ipsec_set_metadata(str
 		   ntohs(mdata->content.tx.seq));
 }
 
+/* Copy from upstream net/ipv4/esp4.c */
+#ifndef HAVE_ESP_OUTPUT_FILL_TRAILER
+	static
+void esp_output_fill_trailer(u8 *tail, int tfclen, int plen, __u8 proto)
+{ 
+	/* Fill padding... */
+	if (tfclen) {
+		memset(tail, 0, tfclen);
+		tail += tfclen;
+	}
+	do {
+		int i;
+		for (i = 0; i < plen - 2; i++)
+			tail[i] = i + 1;
+	} while (0);
+	tail[plen - 2] = plen - 2;
+	tail[plen - 1] = proto;
+}
+#endif
+
 void mlx5e_ipsec_handle_tx_wqe(struct mlx5e_tx_wqe *wqe,
 			       struct mlx5e_accel_tx_ipsec_state *ipsec_st,
 			       struct mlx5_wqe_inline_seg *inlseg)
@@ -312,12 +336,16 @@ void mlx5e_ipsec_tx_build_eseg(struct ml
 	struct xfrm_offload *xo = xfrm_offload(skb);
 	struct xfrm_encap_tmpl  *encap;
 	struct xfrm_state *x;
+#ifdef SECPATH_SET_RETURN_POINTER
 	struct sec_path *sp;
+#endif
 	u8 l3_proto;
 
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp = skb_sec_path(skb);
 	if (unlikely(sp->len != 1))
 		return;
+#endif
 
 	x = xfrm_input_state(skb);
 	if (unlikely(!x))
@@ -357,12 +385,18 @@ bool mlx5e_ipsec_handle_tx_skb(struct ne
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 	struct xfrm_offload *xo = xfrm_offload(skb);
 	struct mlx5e_ipsec_sa_entry *sa_entry;
-	struct mlx5e_ipsec_metadata *mdata;
+	struct mlx5e_ipsec_metadata *mdata = NULL;
 	struct xfrm_state *x;
+#ifdef SECPATH_SET_RETURN_POINTER
 	struct sec_path *sp;
+#endif
 
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp = skb_sec_path(skb);
 	if (unlikely(sp->len != 1)) {
+#else
+	if (unlikely(skb->sp->len != 1)) {
+#endif
 		atomic64_inc(&priv->ipsec->sw_stats.ipsec_tx_drop_bundle);
 		goto drop;
 	}
@@ -415,11 +449,18 @@ mlx5e_ipsec_build_sp(struct net_device *
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 	struct xfrm_offload *xo;
 	struct xfrm_state *xs;
+#ifdef SECPATH_SET_RETURN_POINTER
 	struct sec_path *sp;
+#endif
 	u32 sa_handle;
 
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp = secpath_set(skb);
 	if (unlikely(!sp)) {
+#else
+	skb->sp = secpath_dup(skb->sp);
+	if (unlikely(!skb->sp)) {
+#endif
 		atomic64_inc(&priv->ipsec->sw_stats.ipsec_rx_drop_sp_alloc);
 		return NULL;
 	}
@@ -431,9 +472,14 @@ mlx5e_ipsec_build_sp(struct net_device *
 		return NULL;
 	}
 
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp = skb_sec_path(skb);
 	sp->xvec[sp->len++] = xs;
 	sp->olen++;
+#else
+	skb->sp->xvec[skb->sp->len++] = xs;
+	skb->sp->olen++;
+#endif
 
 	xo = xfrm_offload(skb);
 	xo->flags = CRYPTO_DONE;
@@ -493,7 +539,9 @@ handle_rx_skb_full(struct mlx5e_priv *pr
 		   struct mlx5_cqe64 *cqe)
 {
 	struct xfrm_state *xs;
+#ifdef SECPATH_SET_RETURN_POINTER
 	struct sec_path *sp;
+#endif
 	struct iphdr *v4_hdr;
 	u8 ip_ver;
 
@@ -507,11 +555,20 @@ handle_rx_skb_full(struct mlx5e_priv *pr
 	if (!xs)
 		return;
 
-	sp = secpath_set(skb);
-	if (unlikely(!sp))
+#ifdef SECPATH_SET_RETURN_POINTER
+       sp = secpath_set(skb);
+       if (unlikely(!sp))
+#else
+	skb->sp = secpath_dup(skb->sp);
+	if (unlikely(!skb->sp))
+#endif
 		return;
 
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp->xvec[sp->len++] = xs;
+#else
+	skb->sp->xvec[skb->sp->len++] = xs;
+#endif
 	return;
 }
 
@@ -523,12 +580,19 @@ handle_rx_skb_inline(struct mlx5e_priv *
 	u32 ipsec_meta_data = be32_to_cpu(cqe->ft_metadata);
 	struct xfrm_offload *xo;
 	struct xfrm_state *xs;
+#ifdef SECPATH_SET_RETURN_POINTER
 	struct sec_path *sp;
+#endif
 	u32  sa_handle;
 
 	sa_handle = MLX5_IPSEC_METADATA_HANDLE(ipsec_meta_data);
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp = secpath_set(skb);
 	if (unlikely(!sp)) {
+#else
+	skb->sp = secpath_dup(skb->sp);
+	if (unlikely(!skb->sp)) {
+#endif
 		atomic64_inc(&priv->ipsec->sw_stats.ipsec_rx_drop_sp_alloc);
 		return;
 	}
@@ -539,9 +603,14 @@ handle_rx_skb_inline(struct mlx5e_priv *
 		return;
 	}
 
+#ifdef SECPATH_SET_RETURN_POINTER
 	sp = skb_sec_path(skb);
 	sp->xvec[sp->len++] = xs;
 	sp->olen++;
+#else
+	skb->sp->xvec[skb->sp->len++] = xs;
+	skb->sp->olen++;
+#endif
 
 	xo = xfrm_offload(skb);
 	xo->flags = CRYPTO_DONE;
