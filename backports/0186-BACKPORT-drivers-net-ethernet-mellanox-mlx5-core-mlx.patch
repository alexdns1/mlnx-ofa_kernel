From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h

Change-Id: I1e6274b4a28d613eae6e2101680bf296c46d139d
---
 .../ethernet/mellanox/mlx5/core/mlx5_core.h   | 41 +++++++++++++++----
 1 file changed, 33 insertions(+), 8 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -234,7 +234,9 @@ void mlx5_sriov_cleanup(struct mlx5_core
 int mlx5_sriov_attach(struct mlx5_core_dev *dev);
 void mlx5_sriov_detach(struct mlx5_core_dev *dev);
 int mlx5_core_sriov_configure(struct pci_dev *dev, int num_vfs);
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 int mlx5_core_sriov_set_msix_vec_count(struct pci_dev *vf, int msix_vec_count);
+#endif
 int mlx5_core_enable_hca(struct mlx5_core_dev *dev, u16 func_id);
 int mlx5_sriov_sysfs_init(struct mlx5_core_dev *dev);
 void mlx5_sriov_sysfs_cleanup(struct mlx5_core_dev *dev);
@@ -294,18 +296,21 @@ void mlx5_attach_device_by_protocol(stru
 void mlx5_detach_device(struct mlx5_core_dev *dev);
 int mlx5_register_device(struct mlx5_core_dev *dev);
 void mlx5_unregister_device(struct mlx5_core_dev *dev);
+#if defined(HAVE_LINUX_DEVICE_BUS_H) || defined(HAVE_BUS_FIND_DEVICE_GET_CONST)
+struct mlx5_core_dev *mlx5_get_next_dev(struct mlx5_core_dev *dev,
+                                        int (*match)(struct device *dev,
+					const void *data));
+#else
+struct mlx5_core_dev *mlx5_get_next_dev(struct mlx5_core_dev *dev,
+                                        int (*match)(struct device *dev,
+					void *data));
+#endif
 struct mlx5_core_dev *mlx5_get_next_phys_dev(struct mlx5_core_dev *dev);
 struct mlx5_core_dev *mlx5_get_next_phys_dev_lag(struct mlx5_core_dev *dev);
 void mlx5_dev_list_lock(void);
 void mlx5_dev_list_unlock(void);
 int mlx5_dev_list_trylock(void);
 
-int mlx5_eswitch_offloads_config_single_fdb(struct mlx5_eswitch *master_esw,
-					    struct mlx5_eswitch *slave_esw);
-void mlx5_eswitch_offloads_destroy_single_fdb(struct mlx5_eswitch *master_esw,
-					      struct mlx5_eswitch *slave_esw);
-int mlx5_eswitch_reload_reps(struct mlx5_eswitch *esw);
-
 int mlx5_query_mtpps(struct mlx5_core_dev *dev, u32 *mtpps, u32 mtpps_size);
 int mlx5_set_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size);
 int mlx5_query_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 *arm, u8 *mode);
@@ -319,8 +324,11 @@ void mlx5_dm_cleanup(struct mlx5_core_de
 			    MLX5_CAP_MCAM_FEATURE((mdev), mtpps_fs) &&	\
 			    MLX5_CAP_MCAM_FEATURE((mdev), mtpps_enh_out_per_adj))
 
-int mlx5_firmware_flash(struct mlx5_core_dev *dev, const struct firmware *fw,
-			struct netlink_ext_ack *extack);
+int mlx5_firmware_flash(struct mlx5_core_dev *dev, const struct firmware *fw
+#ifdef HAVE_NETLINK_EXT_ACK
+			, struct netlink_ext_ack *extack
+#endif
+);
 int mlx5_fw_version_query(struct mlx5_core_dev *dev,
 			  u32 *running_ver, u32 *stored_ver);
 
@@ -426,6 +434,21 @@ enum {
 	MLX5_NIC_IFC_SW_RESET		= 7
 };
 
+#ifdef CONFIG_MLX5_ESWITCH
+int mlx5_eswitch_offloads_config_single_fdb(struct mlx5_eswitch *master_esw,
+					    struct mlx5_eswitch *slave_esw);
+void mlx5_eswitch_offloads_destroy_single_fdb(struct mlx5_eswitch *master_esw,
+					      struct mlx5_eswitch *slave_esw);
+int mlx5_eswitch_reload_reps(struct mlx5_eswitch *esw);
+
+#else
+static inline int mlx5_eswitch_reload_reps(struct mlx5_eswitch *esw) { return 0; }
+static inline int mlx5_eswitch_offloads_config_single_fdb(struct mlx5_eswitch *master_esw,
+				    		 struct mlx5_eswitch *slave_esw) { return 0; }
+static inline void mlx5_eswitch_offloads_destroy_single_fdb(struct mlx5_eswitch *master_esw,
+                                		   struct mlx5_eswitch *slave_esw) { return;  }
+#endif
+
 u8 mlx5_get_nic_state(struct mlx5_core_dev *dev);
 void mlx5_set_nic_state(struct mlx5_core_dev *dev, u8 state);
 
@@ -448,12 +471,14 @@ int mlx5_load_one(struct mlx5_core_dev *
 int mlx5_vport_get_other_func_cap(struct mlx5_core_dev *dev, u16 function_id, void *out);
 
 void mlx5_events_work_enqueue(struct mlx5_core_dev *dev, struct work_struct *work);
+#ifdef HAVE_SRIOV_GET_SET_MSIX_VEC_COUNT
 static inline u32 mlx5_sriov_get_vf_total_msix(struct pci_dev *pdev)
 {
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
 
 	return MLX5_CAP_GEN_MAX(dev, num_total_dynamic_vf_msix);
 }
+#endif
 
 bool mlx5_same_hw_devs(struct mlx5_core_dev *dev, struct mlx5_core_dev *peer_dev);
 
