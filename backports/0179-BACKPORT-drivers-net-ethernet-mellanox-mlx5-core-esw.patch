From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/eswitch.c

Change-Id: I45f3332df7a4dc203cd5f8ad5770a17653b6ed9c
---
 .../net/ethernet/mellanox/mlx5/core/eswitch.c | 41 ++++++++++++++++++-
 1 file changed, 39 insertions(+), 2 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -865,6 +865,7 @@ static bool element_type_supported(struc
 }
 
 /* Vport QoS management */
+#if IS_ENABLED(CONFIG_MLXDEVM)
 static int mlx5_devm_rate_group_register(struct mlx5_vgroup *group, const char *name)
 {
 	int err;
@@ -886,6 +887,7 @@ static void mlx5_devm_rate_group_unregis
 				      &group->devm);
 	kfree(group->devm.name);
 }
+#endif
 
 struct mlx5_vgroup *esw_create_vgroup(struct mlx5_eswitch *esw,
 				      u32 group_id, const char *name)
@@ -921,9 +923,13 @@ struct mlx5_vgroup *esw_create_vgroup(st
 	group->tsar_ix = tsar_ix;
 	group->dev = dev;
 
+#if IS_ENABLED(CONFIG_MLXDEVM)
 	if (name)
 		err = mlx5_devm_rate_group_register(group, name);
 	else
+#else
+	if (!name)
+#endif
 		err = mlx5_create_vf_group_sysfs(dev, group->group_id, &group->kobj);
 
 	if (err)
@@ -953,9 +959,13 @@ void esw_destroy_vgroup(struct mlx5_eswi
 
 	list_del(&group->list);
 
+#if IS_ENABLED(CONFIG_MLXDEVM)
 	if (group->devm.name)
 		mlx5_devm_rate_group_unregister(group);
 	else
+#else
+	if (!group->devm.name)
+#endif
 		mlx5_destroy_vf_group_sysfs(esw->dev, &group->kobj);
 
 	err = mlx5_destroy_scheduling_element_cmd(esw->dev,
@@ -1353,7 +1363,7 @@ int mlx5_esw_vport_enable(struct mlx5_es
 			  enum mlx5_eswitch_vport_event enabled_events)
 {
 	struct mlx5_vport *vport;
-	int ret;
+	int ret = 0;
 
 	vport = mlx5_eswitch_get_vport(esw, vport_num);
 	if (IS_ERR(vport))
@@ -1911,8 +1921,11 @@ int mlx5_eswitch_enable(struct mlx5_eswi
 void mlx5_eswitch_disable_locked(struct mlx5_eswitch *esw, bool clear_vf)
 {
 	int old_mode;
-
+#ifdef HAVE_LOCKUP_ASSERT_HELD_WRITE
 	lockdep_assert_held_write(&esw->mode_lock);
+#else
+	lockdep_assert_held(&esw->mode_lock);
+#endif
 
 	if (esw->mode == MLX5_ESWITCH_NONE)
 		return;
@@ -2431,7 +2444,11 @@ is_port_function_supported(struct mlx5_e
 	       mlx5_esw_is_sf_vport(esw, vport_num);
 }
 
+#ifdef HAVE_PORT_FUNCTION_HW_ADDR_GET_GET_4_PARAM
+int mlx5_devlink_port_function_hw_addr_get(
+#else
 int mlx5_devlink_port_function_hw_addr_get(struct devlink *devlink,
+#endif
 					   struct devlink_port *port,
 					   u8 *hw_addr, int *hw_addr_len,
 					   struct netlink_ext_ack *extack)
@@ -2441,7 +2458,11 @@ int mlx5_devlink_port_function_hw_addr_g
 	int err = -EOPNOTSUPP;
 	u16 vport_num;
 
+#ifdef HAVE_PORT_FUNCTION_HW_ADDR_GET_GET_4_PARAM
+	esw = mlx5_devlink_eswitch_get(port->devlink);
+#else
 	esw = mlx5_devlink_eswitch_get(devlink);
+#endif
 	if (IS_ERR(esw))
 		return PTR_ERR(esw);
 
@@ -2489,7 +2510,11 @@ mlx5_esw_set_hca_trusted(struct mlx5_esw
 	return mlx5_core_access_reg(esw->dev, in, sz, out, sz, MLX5_REG_TRUST_LEVEL, 0, 1);
 }
 
+#ifdef HAVE_PORT_FUNCTION_HW_ADDR_GET_GET_4_PARAM
+int mlx5_devlink_port_function_hw_addr_set(
+#else
 int mlx5_devlink_port_function_hw_addr_set(struct devlink *devlink,
+#endif
 					   struct devlink_port *port,
 					   const u8 *hw_addr, int hw_addr_len,
 					   struct netlink_ext_ack *extack)
@@ -2499,7 +2524,11 @@ int mlx5_devlink_port_function_hw_addr_s
 	int err = -EOPNOTSUPP;
 	u16 vport_num;
 
+#ifdef HAVE_PORT_FUNCTION_HW_ADDR_GET_GET_4_PARAM
+	esw = mlx5_devlink_eswitch_get(port->devlink);
+#else
 	esw = mlx5_devlink_eswitch_get(devlink);
+#endif
 	if (IS_ERR(esw)) {
 		NL_SET_ERR_MSG_MOD(extack, "Eswitch doesn't support set hw_addr");
 		return PTR_ERR(esw);
@@ -2781,9 +2810,13 @@ int mlx5_eswitch_get_vport_config(struct
 	ivi->linkstate = evport->info.link_state;
 	ivi->vlan = evport->info.vlan;
 	ivi->qos = evport->info.qos;
+#ifdef HAVE_VF_VLAN_PROTO
 	ivi->vlan_proto = evport->info.vlan_proto;
+#endif
 	ivi->spoofchk = evport->info.spoofchk;
+#ifdef HAVE_VF_INFO_TRUST
 	ivi->trusted = evport->info.trusted;
+#endif
 	ivi->min_tx_rate = evport->qos.min_rate;
 	ivi->max_tx_rate = evport->qos.max_rate;
 	mutex_unlock(&esw->state_lock);
@@ -3235,7 +3268,9 @@ int mlx5_eswitch_get_vport_stats(struct
 	struct mlx5_vport *vport = mlx5_eswitch_get_vport(esw, vport_num);
 	int outlen = MLX5_ST_SZ_BYTES(query_vport_counter_out);
 	u32 in[MLX5_ST_SZ_DW(query_vport_counter_in)] = {};
+#ifdef HAVE_STRUCT_IFLA_VF_STATS_RX_TX_DROPPED
 	struct mlx5_vport_drop_stats stats = {};
+#endif
 	int err = 0;
 	u32 *out;
 
@@ -3295,11 +3330,13 @@ int mlx5_eswitch_get_vport_stats(struct
 	vf_stats->broadcast =
 		MLX5_GET_CTR(out, received_eth_broadcast.packets);
 
+#ifdef HAVE_STRUCT_IFLA_VF_STATS_RX_TX_DROPPED
 	err = mlx5_esw_query_vport_drop_stats(esw->dev, vport, &stats);
 	if (err)
 		goto free_out;
 	vf_stats->rx_dropped = stats.rx_dropped;
 	vf_stats->tx_dropped = stats.tx_dropped;
+#endif
 
 free_out:
 	kvfree(out);
