From: Valentine Fatiev <valentinef@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/base/auxiliary.c

Change-Id: Ib82b4094e7112f4f91617080e1ca7baf828968c4
---
 drivers/base/auxiliary.c | 56 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

--- a/drivers/base/auxiliary.c
+++ b/drivers/base/auxiliary.c
@@ -19,7 +19,10 @@
 #include <linux/pm_runtime.h>
 #include <linux/string.h>
 #include <linux/auxiliary_bus.h>
+#include <linux/acpi.h>
+#ifdef CONFIG_COMPAT_AUXILIARY_EXTERNAL_INIT
 #include "base.h"
+#endif
 
 static const struct auxiliary_device_id *auxiliary_match_id(const struct auxiliary_device_id *id,
 							    const struct auxiliary_device *auxdev)
@@ -70,15 +73,29 @@ static int auxiliary_bus_probe(struct de
 	struct auxiliary_device *auxdev = to_auxiliary_dev(dev);
 	int ret;
 
+#ifdef HAVE_DEV_PM_DOMAIN_ATTACH
 	ret = dev_pm_domain_attach(dev, true);
+
+	/* In case of old kernels 4.17 and below do nothing in case of
+	 * failure of ENODEV */
+	if (ret == -ENODEV)
+		ret = 0;
+
 	if (ret) {
 		dev_warn(dev, "Failed to attach to PM Domain : %d\n", ret);
 		return ret;
 	}
+#else
+	acpi_dev_pm_attach(dev, true);
+#endif
 
 	ret = auxdrv->probe(auxdev, auxiliary_match_id(auxdrv->id_table, auxdev));
 	if (ret)
+#ifdef HAVE_DEV_PM_DOMAIN_ATTACH
 		dev_pm_domain_detach(dev, true);
+#else
+		acpi_dev_pm_detach(dev, true);
+#endif
 
 	return ret;
 }
@@ -90,7 +107,11 @@ static int auxiliary_bus_remove(struct d
 
 	if (auxdrv->remove)
 		auxdrv->remove(auxdev);
+#ifdef HAVE_DEV_PM_DOMAIN_ATTACH
 	dev_pm_domain_detach(dev, true);
+#else
+	acpi_dev_pm_detach(dev, true);
+#endif
 
 	return 0;
 }
@@ -212,9 +233,23 @@ EXPORT_SYMBOL_GPL(__auxiliary_device_add
  * if it does.  If the callback returns non-zero, this function will
  * return to the caller and not iterate over any more devices.
  */
+#ifdef HAVE_LINUX_DEVICE_BUS_H
 struct auxiliary_device *auxiliary_find_device(struct device *start,
 					       const void *data,
 					       int (*match)(struct device *dev, const void *data))
+#else
+#ifdef HAVE_BUS_FIND_DEVICE_GET_CONST
+struct auxiliary_device *
+auxiliary_find_device(struct device *start,
+		      const void *data,
+		      int (*match)(struct device *dev, const void *data))
+#else
+struct auxiliary_device *
+auxiliary_find_device(struct device *start,
+		      void *data,
+		      int (*match)(struct device *dev, void *data))
+#endif /* HAVE_BUS_FIND_DEVICE_GET_CONST */
+#endif /* HAVE_LINUX_DEVICE_BUS_H */
 {
 	struct device *dev;
 
@@ -271,7 +306,28 @@ void auxiliary_driver_unregister(struct
 }
 EXPORT_SYMBOL_GPL(auxiliary_driver_unregister);
 
+#ifdef CONFIG_COMPAT_AUXILIARY_EXTERNAL_INIT
 void __init auxiliary_bus_init(void)
 {
 	WARN_ON(bus_register(&auxiliary_bus_type));
 }
+#else
+static int __init auxiliary_bus_init(void)
+{
+	return bus_register(&auxiliary_bus_type);
+}
+
+static void __exit auxiliary_bus_exit(void)
+{
+	bus_unregister(&auxiliary_bus_type);
+}
+
+module_init(auxiliary_bus_init);
+module_exit(auxiliary_bus_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Auxiliary Bus");
+MODULE_INFO(supported, "external");
+MODULE_AUTHOR("David Ertman <david.m.ertman@intel.com>");
+MODULE_AUTHOR("Kiran Patil <kiran.patil@intel.com>");
+#endif
