From: Maher Sanalla <msanalla@nvidia.com>
Subject: [PATCH] BACKPORT:
 drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c

Change-Id: Ib21320505e639ea12404aeb4678e60b2c4318528
---
 .../mellanox/mlx5/core/eswitch_offloads.c     | 79 ++++++++++++++++---
 1 file changed, 70 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -2671,11 +2671,13 @@ int esw_offloads_load_rep(struct mlx5_es
 	if (esw->mode != MLX5_ESWITCH_OFFLOADS)
 		return 0;
 
+#ifdef HAVE_DEVLINK_PORT_ATRRS_SET_GET_SUPPORT
 	if (vport_num != MLX5_VPORT_UPLINK) {
 		err = mlx5_esw_offloads_devlink_port_register(esw, vport_num);
 		if (err)
 			return err;
 	}
+#endif
 
 	err = mlx5_esw_offloads_rep_load(esw, vport_num);
 	if (err)
@@ -2683,8 +2685,10 @@ int esw_offloads_load_rep(struct mlx5_es
 	return err;
 
 load_err:
+#ifdef HAVE_DEVLINK_PORT_ATRRS_SET_GET_SUPPORT
 	if (vport_num != MLX5_VPORT_UPLINK)
 		mlx5_esw_offloads_devlink_port_unregister(esw, vport_num);
+#endif
 	return err;
 }
 
@@ -2695,8 +2699,10 @@ void esw_offloads_unload_rep(struct mlx5
 
 	mlx5_esw_offloads_rep_unload(esw, vport_num);
 
+#ifdef HAVE_DEVLINK_PORT_ATRRS_SET_GET_SUPPORT
 	if (vport_num != MLX5_VPORT_UPLINK)
 		mlx5_esw_offloads_devlink_port_unregister(esw, vport_num);
+#endif
 }
 
 static int esw_set_slave_root_fdb(struct mlx5_core_dev *master,
@@ -3134,7 +3140,11 @@ u32 mlx5_esw_match_metadata_alloc(struct
 
 	/* Metadata is 4 bits of PFNUM and 12 bits of unique id */
 	/* Use only non-zero vport_id (2-4095) for all PF's */
+#ifdef HAVE_IDA_ALLOC_RANGE
 	id = ida_alloc_range(&esw->offloads.vport_metadata_ida,
+#else
+	id = ida_simple_get(&esw->offloads.vport_metadata_ida,
+#endif
 			     MLX5_ESW_METADATA_RSVD_UPLINK + 1,
 			     vport_end_ida, GFP_KERNEL);
 	if (id < 0)
@@ -3148,7 +3158,11 @@ void mlx5_esw_match_metadata_free(struct
 	u32 vport_bit_mask = (1 << ESW_VPORT_BITS) - 1;
 
 	/* Metadata contains only 12 bits of actual ida id */
-	ida_free(&esw->offloads.vport_metadata_ida, metadata & vport_bit_mask);
+#ifdef HAVE_IDA_FREE
+       ida_free(&esw->offloads.vport_metadata_ida, metadata & vport_bit_mask);
+#else
+	ida_simple_remove(&esw->offloads.vport_metadata_ida, metadata & vport_bit_mask);
+#endif
 }
 
 static int esw_offloads_vport_metadata_setup(struct mlx5_eswitch *esw,
@@ -4085,13 +4099,22 @@ static int eswitch_devlink_esw_mode_chec
 		!mlx5_core_is_ecpf_esw_manager(esw->dev)) ? -EOPNOTSUPP : 0;
 }
 
-int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,
-				  struct netlink_ext_ack *extack)
+int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode
+#ifdef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+				 , struct netlink_ext_ack *extack
+#endif
+				 )
 {
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	struct netlink_ext_ack *extack;
+#endif
 	u16 cur_mlx5_mode, mlx5_mode = 0;
 	struct mlx5_eswitch *esw;
 	
 	int err = 0;
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	extack = NULL;
+#endif
 
 	esw = mlx5_devlink_eswitch_get(devlink);
 	if (IS_ERR(esw))
@@ -4127,12 +4150,14 @@ int mlx5_devlink_eswitch_mode_set(struct
 	}
 
 	if (mode == DEVLINK_ESWITCH_MODE_SWITCHDEV) {
+#ifdef HAVE_DEVLINK_TRAP_SUPPORT
 		if (mlx5_devlink_trap_get_num_active(esw->dev)) {
 			NL_SET_ERR_MSG_MOD(extack,
 					"Can't change mode while devlink traps are active");
 			err = -EOPNOTSUPP;
 			goto unlock;
 		}
+#endif
 		err = esw_offloads_start(esw, extack);
 	} else if (mode == DEVLINK_ESWITCH_MODE_LEGACY) {
 		err = esw_offloads_stop(esw, extack);
@@ -4206,14 +4231,23 @@ revert_inline_mode:
 	return err;
 }
 
-int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode,
-					 struct netlink_ext_ack *extack)
+int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode
+#ifdef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+				 	, struct netlink_ext_ack *extack
+#endif
+				 	)
 {
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	struct netlink_ext_ack *extack;
+#endif
 	struct mlx5_core_dev *dev = devlink_priv(devlink);
 	struct mlx5_eswitch *esw;
 	u8 mlx5_mode;
 	int err;
 
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	extack = NULL;
+#endif
 	esw = mlx5_devlink_eswitch_get(devlink);
 	if (IS_ERR(esw))
 		return PTR_ERR(esw);
@@ -4286,12 +4320,25 @@ unlock:
 }
 
 int mlx5_devlink_eswitch_encap_mode_set(struct devlink *devlink,
-					enum devlink_eswitch_encap_mode encap,
-					struct netlink_ext_ack *extack)
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_ENCAP_MODE_SET_GET_WITH_ENUM
+					enum devlink_eswitch_encap_mode encap
+#else
+					u8 encap
+#endif
+#ifdef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+				 	, struct netlink_ext_ack *extack
+#endif
+				 	)
 {
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	struct netlink_ext_ack *extack;
+#endif
 	struct mlx5_core_dev *dev = devlink_priv(devlink);
 	struct mlx5_eswitch *esw;
 	int err;
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	extack = NULL;
+#endif
 
 	esw = mlx5_devlink_eswitch_get(devlink);
 	if (IS_ERR(esw))
@@ -4348,7 +4395,11 @@ unlock:
 }
 
 int mlx5_devlink_eswitch_encap_mode_get(struct devlink *devlink,
+#ifdef HAVE_DEVLINK_HAS_ESWITCH_ENCAP_MODE_SET_GET_WITH_ENUM
 					enum devlink_eswitch_encap_mode *encap)
+#else
+					u8 *encap)
+#endif
 {
 	struct mlx5_eswitch *esw;
 	int err;
@@ -4387,14 +4438,24 @@ mlx5_eswitch_vport_has_rep(const struct
 }
 
 int mlx5_devlink_eswitch_ipsec_mode_set(struct devlink *devlink,
-					enum devlink_eswitch_ipsec_mode ipsec,
-					struct netlink_ext_ack *extack)
+					enum devlink_eswitch_ipsec_mode ipsec
+#ifdef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+					, struct netlink_ext_ack *extack
+#endif
+)
 {
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	struct netlink_ext_ack *extack;
+#endif
 	struct mlx5_core_dev *dev = devlink_priv(devlink);
 	struct mlx5_eswitch *esw = dev->priv.eswitch;
 	int err = 0;
 
+#ifndef HAVE_DEVLINK_ESWITCH_MODE_SET_EXTACK
+	extack = NULL;
+#else
 	memset(extack, 0, sizeof(*extack));
+#endif
 
 	esw = mlx5_devlink_eswitch_get(devlink);
 	if (IS_ERR(esw))
