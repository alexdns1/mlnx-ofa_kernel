From: Tom Wu <tomwu@mellanox.com>
Subject: [PATCH] BACKPORT: net/sunrpc/xprtrdma/frwr_ops.c

Change-Id: I476a2310aad91ce59caed55438baeef477a396cb
---
 net/sunrpc/xprtrdma/frwr_ops.c | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@ -44,7 +44,9 @@
 #include <linux/sunrpc/svc_rdma.h>
 
 #include "xprt_rdma.h"
+#ifdef HAVE_TRACE_RPCRDMA_H
 #include <trace/events/rpcrdma.h>
+#endif
 
 #ifdef CONFIG_NVFS
 #define NVFS_FRWR
@@ -66,8 +68,10 @@ void frwr_release_mr(struct rpcrdma_mr *
 	int rc;
 
 	rc = ib_dereg_mr(mr->frwr.fr_mr);
+#ifdef HAVE_TRACE_RPCRDMA_H
 	if (rc)
 		trace_xprtrdma_frwr_dereg(mr, rc);
+#endif
 	kfree(mr->mr_sg);
 	kfree(mr);
 }
@@ -76,10 +80,14 @@ static void frwr_mr_recycle(struct rpcrd
 {
 	struct rpcrdma_xprt *r_xprt = mr->mr_xprt;
 
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_mr_recycle(mr);
+#endif
 
 	if (mr->mr_dir != DMA_NONE) {
+#ifdef HAVE_TRACE_RPCRDMA_H
 		trace_xprtrdma_mr_unmap(mr);
+#endif
 #ifdef CONFIG_NVFS
 		if (rpcrdma_nvfs_unmap_data(r_xprt->rx_ia.ri_id->device->dma_device,
 					    mr->mr_sg, mr->mr_nents, mr->mr_dir))
@@ -152,7 +160,9 @@ int frwr_init_mr(struct rpcrdma_ia *ia,
 
 out_mr_err:
 	rc = PTR_ERR(frmr);
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_frwr_alloc(mr, rc);
+#endif
 	return rc;
 
 out_list_err:
@@ -369,17 +379,23 @@ struct rpcrdma_mr_seg *frwr_map(struct r
 	mr->mr_handle = ibmr->rkey;
 	mr->mr_length = ibmr->length;
 	mr->mr_offset = ibmr->iova;
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_mr_map(mr);
+#endif
 
 	return seg;
 
 out_dmamap_err:
 	mr->mr_dir = DMA_NONE;
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_frwr_sgerr(mr, i);
+#endif
 	return ERR_PTR(-EIO);
 
 out_mapmr_err:
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_frwr_maperr(mr, n);
+#endif
 	return ERR_PTR(-EIO);
 }
 
@@ -391,6 +407,7 @@ out_mapmr_err:
  */
 static void frwr_wc_fastreg(struct ib_cq *cq, struct ib_wc *wc)
 {
+#ifdef HAVE_TRACE_RPCRDMA_H
 	struct ib_cqe *cqe = wc->wr_cqe;
 	struct rpcrdma_frwr *frwr =
 		container_of(cqe, struct rpcrdma_frwr, fr_cqe);
@@ -398,6 +415,7 @@ static void frwr_wc_fastreg(struct ib_cq
 	/* WARNING: Only wr_cqe and status are reliable at this point */
 	trace_xprtrdma_wc_fastreg(wc, frwr);
 	/* The MR will get recycled when the associated req is retransmitted */
+#endif
 }
 
 /**
@@ -448,7 +466,9 @@ void frwr_reminv(struct rpcrdma_rep *rep
 	list_for_each_entry(mr, mrs, mr_list)
 		if (mr->mr_handle == rep->rr_inv_rkey) {
 			list_del_init(&mr->mr_list);
+#ifdef HAVE_TRACE_RPCRDMA_H
 			trace_xprtrdma_mr_remoteinv(mr);
+#endif
 			rpcrdma_mr_put(mr);
 			break;	/* only one invalidated MR per RPC */
 		}
@@ -476,7 +496,9 @@ static void frwr_wc_localinv(struct ib_c
 	struct rpcrdma_mr *mr = container_of(frwr, struct rpcrdma_mr, frwr);
 
 	/* WARNING: Only wr_cqe and status are reliable at this point */
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_wc_li(wc, frwr);
+#endif
 	__frwr_release_mr(wc, mr);
 }
 
@@ -495,7 +517,9 @@ static void frwr_wc_localinv_wake(struct
 	struct rpcrdma_mr *mr = container_of(frwr, struct rpcrdma_mr, frwr);
 
 	/* WARNING: Only wr_cqe and status are reliable at this point */
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_wc_li_wake(wc, frwr);
+#endif
 	__frwr_release_mr(wc, mr);
 	complete(&frwr->fr_linv_done);
 }
@@ -528,7 +552,9 @@ void frwr_unmap_sync(struct rpcrdma_xprt
 	prev = &first;
 	while ((mr = rpcrdma_mr_pop(&req->rl_registered))) {
 
+#ifdef HAVE_TRACE_RPCRDMA_H
 		trace_xprtrdma_mr_localinv(mr);
+#endif
 		r_xprt->rx_stats.local_inv_needed++;
 
 		frwr = &mr->frwr;
@@ -571,7 +597,9 @@ void frwr_unmap_sync(struct rpcrdma_xprt
 
 	/* Recycle MRs in the LOCAL_INV chain that did not get posted.
 	 */
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_post_linv(req, rc);
+#endif
 	while (bad_wr) {
 		frwr = container_of(bad_wr, struct rpcrdma_frwr,
 				    fr_invwr);
@@ -598,7 +626,9 @@ static void frwr_wc_localinv_done(struct
 	struct rpcrdma_rep *rep = mr->mr_req->rl_reply;
 
 	/* WARNING: Only wr_cqe and status are reliable at this point */
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_wc_li_done(wc, frwr);
+#endif
 	__frwr_release_mr(wc, mr);
 
 	/* Ensure @rep is generated before __frwr_release_mr */
@@ -631,7 +661,9 @@ void frwr_unmap_async(struct rpcrdma_xpr
 	prev = &first;
 	while ((mr = rpcrdma_mr_pop(&req->rl_registered))) {
 
+#ifdef HAVE_TRACE_RPCRDMA_H
 		trace_xprtrdma_mr_localinv(mr);
+#endif
 		r_xprt->rx_stats.local_inv_needed++;
 
 		frwr = &mr->frwr;
@@ -667,7 +699,9 @@ void frwr_unmap_async(struct rpcrdma_xpr
 
 	/* Recycle MRs in the LOCAL_INV chain that did not get posted.
 	 */
+#ifdef HAVE_TRACE_RPCRDMA_H
 	trace_xprtrdma_post_linv(req, rc);
+#endif
 	while (bad_wr) {
 		frwr = container_of(bad_wr, struct rpcrdma_frwr, fr_invwr);
 		mr = container_of(frwr, struct rpcrdma_mr, frwr);
