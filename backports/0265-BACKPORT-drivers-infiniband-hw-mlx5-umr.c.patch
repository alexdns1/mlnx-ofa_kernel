From: Avihai Horon <avihaih@nvidia.com>
Subject: [PATCH] BACKPORT: drivers/infiniband/hw/mlx5/umr.c

Change-Id: I3a59fef6725ccd4cfcb75449d9e48fcae3f0de64
---
 drivers/infiniband/hw/mlx5/umr.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

--- a/drivers/infiniband/hw/mlx5/umr.c
+++ b/drivers/infiniband/hw/mlx5/umr.c
@@ -380,10 +380,14 @@ static void mlx5r_umr_set_access_flags(s
 				       struct mlx5_mkey_seg *seg,
 				       unsigned int access_flags)
 {
+#ifdef HAVE_PCIE_RELAXED_ORDERING_ENABLED
 	bool ro_read = (access_flags & IB_ACCESS_RELAXED_ORDERING) &&
 		       (MLX5_CAP_GEN(dev->mdev, relaxed_ordering_read) ||
 			mlx5_core_is_vf(dev->mdev) ||
 			pcie_relaxed_ordering_enabled(dev->mdev->pdev));
+#else
+	bool ro_read = access_flags & IB_ACCESS_RELAXED_ORDERING;
+#endif
 
 	MLX5_SET(mkc, seg, a, !!(access_flags & IB_ACCESS_REMOTE_ATOMIC));
 	MLX5_SET(mkc, seg, rw, !!(access_flags & IB_ACCESS_REMOTE_WRITE));
@@ -436,7 +440,9 @@ static void *mlx5r_umr_alloc_xlt(size_t
 	size_t size;
 	void *res = NULL;
 
+#ifdef HAVE_STATIC_ASSERT
 	static_assert(PAGE_SIZE % MLX5_UMR_MTT_ALIGNMENT == 0);
+#endif
 
 	/*
 	 * MLX5_IB_UPD_XLT_ATOMIC doesn't signal an atomic context just that the
@@ -640,8 +646,12 @@ int mlx5r_umr_update_mr_pas(struct mlx5_
 	mlx5r_umr_set_update_xlt_data_seg(&wqe.data_seg, &sg);
 
 	cur_mtt = mtt;
+#ifdef HAVE_SG_APPEND_TABLE
 	rdma_for_each_block(mr->umem->sgt_append.sgt.sgl, &biter,
 			    mr->umem->sgt_append.sgt.nents,
+#else
+	rdma_for_each_block (mr->umem->sg_head.sgl, &biter, mr->umem->nmap,
+#endif
 			    BIT(mr->page_shift)) {
 		if (cur_mtt == (void *)mtt + sg.length) {
 			dma_sync_single_for_device(ddev, sg.addr, sg.length,
